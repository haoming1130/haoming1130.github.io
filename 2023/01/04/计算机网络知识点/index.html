<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>计算机网络知识点 | 小明学习博客</title><meta name="author" content="Haoming Lu"><meta name="copyright" content="Haoming Lu"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="总结计算机网络基础常见的面试题考点内容">
<meta property="og:type" content="article">
<meta property="og:title" content="计算机网络知识点">
<meta property="og:url" content="http://haoming1130.github.io/2023/01/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9/index.html">
<meta property="og:site_name" content="小明学习博客">
<meta property="og:description" content="总结计算机网络基础常见的面试题考点内容">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s2.loli.net/2022/12/04/IWqKCzP5gwNfbVL.jpg">
<meta property="article:published_time" content="2023-01-04T13:14:52.353Z">
<meta property="article:modified_time" content="2023-01-13T14:07:32.478Z">
<meta property="article:author" content="Haoming Lu">
<meta property="article:tag" content="计算机网络">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s2.loli.net/2022/12/04/IWqKCzP5gwNfbVL.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://haoming1130.github.io/2023/01/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '计算机网络知识点',
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isToc: true,
  postUpdate: '2023-01-13 22:07:32'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://unpkg.zhimg.com/hexo-butterfly-footer-beautify@1.0.0/lib/runtime.min.css" media="print" onload="this.media='all'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">51</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">5</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-envelope"></i><span> 留言板</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://s2.loli.net/2022/12/04/IWqKCzP5gwNfbVL.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">小明学习博客</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-envelope"></i><span> 留言板</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">计算机网络知识点</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-01-04T13:14:52.353Z" title="发表于 2023-01-04 21:14:52">2023-01-04</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-01-13T14:07:32.478Z" title="更新于 2023-01-13 22:07:32">2023-01-13</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%9F%A5%E8%AF%86%E7%82%B9/">知识点</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">29.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>90分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="计算机网络知识点"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="计算机网络知识点"><a href="#计算机网络知识点" class="headerlink" title="计算机网络知识点"></a>计算机网络知识点</h1><p>本文参考：<a target="_blank" rel="noopener" href="https://www.xiaolincoding.com/network/2_http/http_interview.html#%E4%BB%80%E4%B9%88%E6%98%AF%E5%BC%BA%E5%88%B6%E7%BC%93%E5%AD%98">小林coding</a></p>
<h1 id="TCP-x2F-IP-网络分层模型详解"><a href="#TCP-x2F-IP-网络分层模型详解" class="headerlink" title="TCP&#x2F;IP 网络分层模型详解"></a>TCP&#x2F;IP 网络分层模型详解</h1><p>​		为了使多种设备能通过网络相互通信，和为了解决各种不同设备在网络互联中的兼容性问题，国际标准化组织制定了开放式系统互联通信参考模型(<em>Open System Interconnection Reference Model</em>)，也就是 OSI 网络模型，该模型主要由 <strong>应用层、表示层、会话层、传输层、网络层、数据链路层和物理层</strong> 7层组成。</p>
<p>每一层负责的职能都不同，如下：</p>
<ul>
<li>应用层，负责给应用程序提供统一的接口；</li>
<li>表示层，负责把数据转换成兼容另一个系统能识别的格式；</li>
<li>会话层，负责建立、管理和终止表示层实体之间的通信会话；</li>
<li>传输层，负责端到端的数据传输；</li>
<li>网络层，负责数据的路由、转发、分片；</li>
<li>数据链路层，负责数据的封帧和差错检测，以及 MAC 寻址；</li>
<li>物理层，负责在物理网络中传输数据帧；</li>
</ul>
<p>​		由于 OSI 模型实在太复杂，提出的也只是概念理论上的分层，并没有提供具体的实现方案。事实上，我们比较常见，也比较实用的是四层模型，即 TCP&#x2F;IP 网络模型</p>
<img src="https://s2.loli.net/2023/01/10/ZSfEe27Kiw49tMv.png" alt="TCPmodel" style="zoom: 67%;" />

<img src="https://s2.loli.net/2023/01/10/h5XFSpdyjR6vaC8.png" alt="TCPdec" style="zoom: 67%;" />



<h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><p>​		应用层（<em>Application Layer</em>）是我们能 <strong>直接接触</strong> 到的网络模型的 <strong>最上层</strong>，应用层是工作在操作系统中的 <strong>用户态</strong>，我们使用的应用软件都是在应用层实现的。</p>
<p>​		应用层不需要关系数据是如何传输的，就类似于我们寄快递的时候，只需要把包裹交给快递员，由他负责运输快递，我们不需要关心快递是如何被运输的。应用层只需要专注于 <strong>为用户提供应用功能</strong>，比如HTTP、FTP、Telnet、DNS、SMTP等。</p>
<h3 id="应用层协议简述"><a href="#应用层协议简述" class="headerlink" title="应用层协议简述"></a>应用层协议简述</h3><ul>
<li>HTTP</li>
</ul>
<p>缺省TCP 80 端口，用于浏览器浏览网页，但网页内容为明文，容易篡改、容易劫持、网页内容容易泄漏</p>
<ul>
<li>HTTPS</li>
</ul>
<p>HTTPS里的<strong>S代表Security</strong>，缺省工作于TCP 443端口，只是在普通的HTTP与TCP层之间多了一个安全加密的夹层，称之为SSL（Secure Socket Layer），用于加密基于HTTP的网页内容，不容易篡改、不容易劫持、网页内容保密，目前广泛用于网上银行等行业。但有安全漏洞，容易受中间人欺骗攻击。</p>
<ul>
<li>SMTP</li>
</ul>
<p>用于邮件发送的基于TCP的应用层协议</p>
<ul>
<li>POP3</li>
</ul>
<p>用于邮件接收的基于TCP的应用层协议</p>
<ul>
<li>DNS</li>
</ul>
<p>用于解析域名与IP地址的基于UDP&#x2F;TCP 应用层协议</p>
<h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><p>​		当两个不同设备的应用需要通信时，应用层将数据传给传输层（<em>Transport Layer</em>），传输层是专门为应用层提供网络支持的。</p>
<p>​		传输层及以下工作都在 <strong>内核态</strong>。</p>
<h3 id="TCP-x2F-UDP"><a href="#TCP-x2F-UDP" class="headerlink" title="TCP&#x2F;UDP"></a>TCP&#x2F;UDP</h3><p>​		在传输层中，有两个传输协议：<strong>TCP</strong> 和 <strong>UDP</strong>。</p>
<p>​		TCP 的全称叫传输控制协议（<em>Transmission Control Protocol</em>），大部分应用使用的正是 TCP 传输层协议，比如 HTTP 应用层协议。TCP 相比 UDP 多了很多特性，比如流量控制、超时重传、拥塞控制等，这些都是为了保证数据包能可靠地传输给对方。</p>
<p>​		UDP 相对来说就很简单，简单到只负责发送数据包，不保证数据包是否能抵达对方，但它实时性相对更好，传输效率也高。当然，UDP 也可以实现可靠传输，把 TCP 的特性在应用层上实现就可以，不过要实现一个商用的可靠 UDP 传输协议，也不是一件简单的事情。</p>
<h3 id="TCP段"><a href="#TCP段" class="headerlink" title="TCP段"></a>TCP段</h3><p>​		应用需要传输的数据可能会非常大，如果直接传输就不好控制，因此当传输层的数据包大小超过 MSS（TCP 最大报文段长度） ，就要将数据包分块，这样即使中途有一个分块丢失或损坏了，只需要重新发送这一个分块，而不用重新发送整个数据包。在 TCP 协议中，我们把每个分块称为一个 <strong>TCP 段</strong>（<em>TCP Segment</em>）。</p>
<img src="https://s2.loli.net/2023/01/10/muOU1dyFeMB5sHk.png" alt="img" style="zoom:67%;" />

<h3 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h3><p>​		当设备作为接收方时，传输层则要负责把数据包传给应用，但是一台设备上可能会有很多应用在接收或者传输数据，因此需要用一个编号将应用区分开来，这个编号就是<strong>端口</strong>。</p>
<p>​		比如 80 端口通常是 Web 服务器用的，22 端口通常是远程登录服务器用的。而对于浏览器（客户端）中的每个标签栏都是一个独立的进程，操作系统会为这些进程分配临时的端口号。</p>
<p>​		由于传输层的报文中会携带端口号，因此接收方可以识别出该报文是发送给哪个应用。</p>
<h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><p>​		传输层 <strong>并不负责</strong> 将数据从一个设备传输到另一个设备，它只是一个 <strong>应用间数据传输的媒介</strong>，通俗来讲，它是上门取件的快递员，具体的快递物流，快递员会交给物流公司运作，而不是带着快递自己送去收件方。</p>
<p>​		实现应用到应用的通信，传输层会将实际的传输功能就交给下一层，也就是<strong>网络层</strong>（<em>Internet Layer</em>）。</p>
<h3 id="IP协议"><a href="#IP协议" class="headerlink" title="IP协议"></a>IP协议</h3><p>​		网络层最常使用的是 IP 协议（<em>Internet Protocol</em>），IP 协议会将 <strong>传输层的报文</strong> 作为数据部分，再加上 IP 包头组装成 IP 报文，如果 IP 报文大小超过 MTU（以太网中一般为 1500 字节）就会<strong>再次进行分片</strong>，得到一个即将发送到网络的 IP 报文。</p>
<img src="https://s2.loli.net/2023/01/10/K68lrjOeZvcoxzU.png" alt="img" style="zoom: 50%;" />

<h3 id="IP地址寻址"><a href="#IP地址寻址" class="headerlink" title="IP地址寻址"></a>IP地址寻址</h3><p>​		网络层需要有 <strong>区分设备的编号</strong>，才能实现将数据从一个设备传输到另一个设备。我们一般用 <strong>IP 地址</strong> 给设备进行编号，对于 IPv4 协议，IP 地址共 32 位，分成了四段（比如，192.168.100.1），每段是 8 位。</p>
<p>​		为了加快寻址效率，通过 <strong>子网掩码</strong> 将IP地址分成了两种意义：</p>
<ul>
<li><strong>网络号</strong>：负责标识该 IP 地址是属于哪个「子网」的；</li>
<li><strong>主机号</strong>：负责标识同一「子网」下的不同主机；</li>
</ul>
<p>​		举个例子，比如 10.100.122.0&#x2F;24，后面的<code>/24</code>表示就是 <code>255.255.255.0</code> 子网掩码。<code>/24</code> 表示的是<code>255.255.255.0</code> 的二进制「11111111-11111111-11111111-00000000」中 1 的个数，为了简化子网掩码的表示，用 <code>/24</code> 代替 <code>255.255.255.0</code>。</p>
<p>​		将 <code>10.100.122.2</code> 和 <code>255.255.255.0</code> 进行<strong>按位与运算</strong>，就可以得到网络号(<code>10.100.122.0</code>)。</p>
<img src="https://s2.loli.net/2023/01/10/vZ8lGDgIznjfQuS.jpg" alt="img" style="zoom:67%;" />

<p>​		</p>
<p>​		将 <code>255.255.255.0</code> 取反后与IP地址进行进行<strong>按位与运算</strong>，就可以得到主机号(0.0.0.2)。</p>
<p>​		在寻址的过程中，先匹配到相同的网络号（表示要找到同一个子网），才会去找对应的主机，大大提高了寻址效率。</p>
<h3 id="IP协议路由功能"><a href="#IP协议路由功能" class="headerlink" title="IP协议路由功能"></a>IP协议路由功能</h3><p>​		IP 协议的寻址作用是告诉我们去往下一个目的地该朝哪个方向走，路由则是根据「下一个目的地」选择路径。<strong>寻址更像在导航，路由更像在操作方向盘</strong>。</p>
<p>​		实际场景中，两台设备并不是用一条网线连接起来的，而是通过很多网关、路由器、交换机等众多网络设备连接起来的，那么就会形成很多条网络的路径，因此当数据包到达一个网络节点，就需要通过 <strong>路由算法</strong> 决定下一步走哪条路径。</p>
<img src="https://s2.loli.net/2023/01/10/ov8XkByYQ42SwnG.png" alt="IP地址的网络号" style="zoom:67%;" />

<h2 id="网络接口层"><a href="#网络接口层" class="headerlink" title="网络接口层"></a>网络接口层</h2><p>​		确定了 IP 地址后，就能够向这个 IP 地址所在的主机发送 <strong>数据报</strong>，但在 <strong>以太网</strong> 中，生成了 IP 头部之后，接下来要交给 <strong>网络接口层</strong>（<em>Link Layer</em>）在 IP 头部的前面加上 MAC 头部，并封装成 <strong>数据帧</strong>（Data frame）发送到以太网上。</p>
<p>​		简而言之，网络接口层主要为网络层提供<strong>「链路级别」</strong>传输的服务，负责在以太网、WiFi 这样的底层网络上发送原始数据包，工作在<strong>网卡</strong>这个层次，使用 MAC 地址来标识网络上的设备。</p>
<h3 id="以太网概念"><a href="#以太网概念" class="headerlink" title="以太网概念"></a>以太网概念</h3><p>​		电脑上的以太网接口，Wi-Fi接口，以太网交换机、路由器上的千兆，万兆以太网口，还有网线，它们都是以太网的组成部分。以太网就是一种在「局域网」内，把附近的设备连接起来，使它们之间可以进行通讯的技术。</p>
<p>​		以太网在判断网络包目的地时和 IP 的方式不同，因此必须采用相匹配的方式才能在以太网中将包发往目的地，而 MAC 头部就是干这个用的，所以，在以太网进行通讯要用到 MAC 地址。</p>
<h3 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h3><p>​		MAC 地址的全称是 Media Access Control Address，译为媒体访问控制地址，也称为物理地址，硬件地址和老化地址。它包含了接收方和发送方的 MAC 地址等信息，我们可以通过 <strong>ARP 协议</strong> 获取对方的 MAC 地址。</p>
<p>​		MAC 地址长 48 bit，在使用 <strong>网卡(NIC)</strong>  的情况下，MAC 地址一般都会烧入 ROM 中。因此，任何一个网卡的 MAC 地址都是唯一的。</p>
<blockquote>
<p>MAC 地址也有例外情况，即 MAC 地址也会有重复的时候，但只要两个 MAC 地址是属于不同的数据链路层就不会出现问题，还是能保证唯一性。</p>
</blockquote>
<img src="https://s2.loli.net/2023/01/10/xBQWIwd18muanMp.png" style="zoom:67%;" />

<p>​		MAC 地址主要用于识别数据链路中互联的节点：</p>
<img src="https://s2.loli.net/2023/01/10/P4Ji3SADNYdZU6X.png" alt="image.png" style="zoom:67%;" />

<h3 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h3><p>​		ARP 协议的全称是 Address Resolution Protocol(地址解析协议)，它是一个通过<strong>用于实现从 IP 地址到 MAC 地址的映射，即询问目标 IP 对应的 MAC 地址</strong> 的一种协议。</p>
<blockquote>
<p>注意：ARP 只用于 IPv4 协议中，IPv6 协议使用的是 Neighbor Discovery Protocol，译为邻居发现协议，它被纳入 ICMPv6 中。</p>
</blockquote>
<h4 id="ARP工作机制"><a href="#ARP工作机制" class="headerlink" title="ARP工作机制"></a>ARP工作机制</h4><p>​		假设 A 和 B 位于<strong>同一链路</strong>，不需要经过路由器的转换，主机 A 向主机 B 发送一个 IP 分组，主机 A 的地址是 <code>192.168.1.2</code> ，主机 B 的地址是 <code>192.168.1.3</code>，它们都不知道对方的 MAC 地址是啥，主机 C 和 主机 D 是同一链路的其他主机。</p>
<img src="https://s2.loli.net/2023/01/10/i5JL3YETxywFWme.png" alt="image.png" style="zoom:67%;" />



<p>​		主机 A 想要获取主机 B 的 MAC 地址，通过主机 A 会通过 <strong>广播</strong> 的方式向以太网上的所有主机发送一个 ARP 请求包，这个 ARP 请求包中包含了主机 A 想要知道的主机 B 的 <strong>IP 地址的 MAC 地址</strong>。</p>
<img src="https://s2.loli.net/2023/01/10/moKwYnO8sVgzcJH.png" alt="image.png" style="zoom:67%;" />

<p>​		主机 A 发送的 ARP 请求包会被同一链路上的所有主机&#x2F;路由器接收并进行解析。每个主机&#x2F;路由器都会检查 ARP 请求包中的信息，如果 ARP 请求包中的 <strong>目标 IP 地址</strong> 和自己的相同，就会将自己主机的 MAC 地址写入响应包返回主机 A。</p>
<img src="https://s2.loli.net/2023/01/10/d7LeRS5iwGquEXO.png" alt="image.png" style="zoom:67%;" />

<p>​		由此，可以通过 ARP 从 IP 地址获取 MAC 地址，实现<strong>同一链路</strong>内的通信。</p>
<blockquote>
<p>如果是不同链路就要使用到 <strong>代理 ARP</strong> ，通常 ARP 会被路由器隔离，但是采用代理 ARP (ARP Proxy) 的路由器可以将 ARP 请求转发给临近的网段。使多个网段中的节点像是在同一网段内通信。</p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​		综上所述，TCP&#x2F;IP 网络通常是由上到下分成 4 层，分别是<strong>应用层，传输层，网络层和网络接口层</strong>。</p>
<img src="https://s2.loli.net/2023/01/10/gYnOZem8dw2rbqD.png" alt="img" style="zoom:50%;" />

<p>​		网络接口层的传输单位是<strong>帧</strong>（frame），IP 层的传输单位是<strong>包</strong>（packet），TCP 层的传输单位是<strong>段</strong>（segment），HTTP 的传输单位则是<strong>消息或报文</strong>（message）。但这些名词并没有什么本质的区分，可以统称为数据包。</p>
<img src="https://s2.loli.net/2023/01/10/6aqd3QuNyfZhRzJ.png" alt="img" style="zoom:50%;" />



<h1 id="应用层-HTTP-x2F-HTTPS"><a href="#应用层-HTTP-x2F-HTTPS" class="headerlink" title="应用层-HTTP&#x2F;HTTPS"></a>应用层-HTTP&#x2F;HTTPS</h1><h2 id="HTTP概念"><a href="#HTTP概念" class="headerlink" title="HTTP概念"></a>HTTP概念</h2><p>​		HTTP 是超文本传输协议，也就是 <strong>H</strong>yper<strong>T</strong>ext <strong>T</strong>ransfer <strong>P</strong>rotocol，它可以拆成三个部分：</p>
<ul>
<li>超文本</li>
<li>传输</li>
<li>协议</li>
</ul>
<img src="https://s2.loli.net/2023/01/11/PKFmNSDb7yhC3wM.png" alt="三个部分" style="zoom: 80%;" />



<p>​		针对 HTTP <strong>协议</strong>，我们可以这么理解：</p>
<p>​		HTTP 是一个用在计算机世界里的<strong>协议</strong>。它使用计算机能够理解的语言确立了一种计算机之间交流通信的规范（<strong>两个以上的参与者</strong>），以及相关的各种控制和错误处理方式（<strong>行为约定和规范</strong>）。</p>
<p>​		针对<strong>传输</strong>，HTTP 是一个在计算机世界里专门用来在<strong>两点之间传输数据</strong>的约定和规范。</p>
<p>​		HTTP 传输的内容是 <strong>超文本</strong>，就是<strong>超越了普通文本的文本</strong>，它是文字、图片、视频等的混合体，最关键有超链接，能从一个超文本跳转到另外一个超文本。</p>
<p>​		归纳概括，<strong>HTTP 是一个在计算机世界里专门在「两点」之间「传输」文字、图片、音频、视频等「超文本」数据的「约定和规范」。</strong></p>
<h3 id="HTTP-常见的状态码"><a href="#HTTP-常见的状态码" class="headerlink" title="HTTP 常见的状态码"></a>HTTP 常见的状态码</h3><img src="https://s2.loli.net/2023/01/11/vsqEzyrU4Fnm3cl.png" alt=" 五大类 HTTP 状态码 " style="zoom:67%;" />

<p><code>1xx</code> 类状态码属于<strong>提示信息</strong>，是协议处理中的一种中间状态，实际用到的比较少。</p>
<p><code>2xx</code> 类状态码表示服务器<strong>成功</strong>处理了客户端的请求，也是我们最愿意看到的状态。</p>
<ul>
<li>「<strong>200 OK</strong>」是最常见的成功状态码，表示一切正常。如果是非 <code>HEAD</code> 请求，服务器返回的响应头都会有 body 数据。</li>
<li>「<strong>204 No Content</strong>」也是常见的成功状态码，与 200 OK 基本相同，但响应头没有 body 数据。</li>
<li>「<strong>206 Partial Content</strong>」是应用于 HTTP 分块下载或断点续传，表示响应返回的 body 数据并不是资源的全部，而是其中的一部分，也是服务器处理成功的状态。</li>
</ul>
<p><code>3xx</code> 类状态码表示客户端请求的资源发生了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是<strong>重定向</strong>。</p>
<ul>
<li>「<strong>301 Moved Permanently</strong>」表示永久重定向，说明请求的资源已经不存在了，需改用新的 URL 再次访问。</li>
<li>「<strong>302 Found</strong>」表示临时重定向，说明请求的资源还在，但暂时需要用另一个 URL 来访问。</li>
</ul>
<p>301 和 302 都会在响应头里使用字段 <code>Location</code>，指明后续要跳转的 URL，浏览器会自动重定向新的 URL。</p>
<ul>
<li>「<strong>304 Not Modified</strong>」不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，也称缓存重定向，也就是告诉客户端可以继续使用缓存资源，用于缓存控制。</li>
</ul>
<p><code>4xx</code> 类状态码表示客户端发送的<strong>报文有误</strong>，服务器无法处理，也就是错误码的含义。</p>
<ul>
<li>「<strong>400 Bad Request</strong>」表示客户端请求的报文有错误，但只是个笼统的错误。</li>
<li>「<strong>403 Forbidden</strong>」表示服务器禁止访问资源，并不是客户端的请求出错。</li>
<li>「<strong>404 Not Found</strong>」表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端。</li>
</ul>
<p><code>5xx</code> 类状态码表示客户端请求报文正确，但是<strong>服务器处理时内部发生了错误</strong>，属于服务器端的错误码。</p>
<ul>
<li>「<strong>500 Internal Server Error</strong>」与 400 类型，是个笼统通用的错误码，服务器发生了什么错误，我们并不知道。</li>
<li>「<strong>501 Not Implemented</strong>」表示客户端请求的功能还不支持，类似“即将开业，敬请期待”的意思。</li>
<li>「<strong>502 Bad Gateway</strong>」通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误。</li>
<li>「<strong>503 Service Unavailable</strong>」表示服务器当前很忙，暂时无法响应客户端，类似“网络服务正忙，请稍后重试”的意思</li>
</ul>
<h2 id="GET-和-POST"><a href="#GET-和-POST" class="headerlink" title="GET 和 POST"></a>GET 和 POST</h2><p>​		根据 RFC 规范，<strong>GET 的语义是从服务器获取指定的资源</strong>，这个资源可以是静态的文本、页面、图片视频等。一般是写在 URL 中。</p>
<p>​		<strong>POST 的语义是根据请求负荷（报文body）对指定的资源做出处理</strong>，具体的处理方式视资源类型而不同。一般是写在报文 body 中。</p>
<h3 id="GET-和-POST-方法都是安全和幂等的吗？"><a href="#GET-和-POST-方法都是安全和幂等的吗？" class="headerlink" title="GET 和 POST 方法都是安全和幂等的吗？"></a>GET 和 POST 方法都是安全和幂等的吗？</h3><p><strong>什么是安全幂等？</strong></p>
<ul>
<li>在 HTTP 协议里，所谓的「安全」是指请求方法不会「破坏」服务器上的资源。</li>
<li>所谓的「幂等」，意思是多次执行相同的操作，结果都是「相同」的。</li>
</ul>
<p>​		从 RFC 规范定义的语义来看：</p>
<ul>
<li><strong>GET 方法就是安全且幂等的</strong>，因为它是「只读」操作，无论操作多少次，服务器上的数据都是安全的，且每次的结果都是相同的。所以，<strong>可以对 GET 请求的数据做缓存，这个缓存可以做到浏览器本身上（彻底避免浏览器发请求），也可以做到代理上（如nginx），而且在浏览器中 GET 请求可以保存为书签</strong>。</li>
<li><strong>POST</strong> 因为是「新增或提交数据」的操作，会修改服务器上的资源，所以是<strong>不安全</strong>的，且多次提交数据就会创建多个资源，所以<strong>不是幂等</strong>的。所以，<strong>浏览器一般不会缓存 POST 请求，也不能把 POST 请求保存为书签</strong>。</li>
</ul>
<p>​		但是实际过程中，开发者不一定会按照 RFC 规范定义的语义来实现 GET 和 POST 方法。所以要避免传输过程中数据被窃取，就要使用 HTTPS 协议，这样所有 HTTP 的数据都会被加密传输。</p>
<h2 id="HTTP特性"><a href="#HTTP特性" class="headerlink" title="HTTP特性"></a>HTTP特性</h2><p>​		到目前为止，HTTP 常见到版本有 HTTP&#x2F;1.1，HTTP&#x2F;2.0，HTTP&#x2F;3.0，不同版本的 HTTP 特性是不一样的。</p>
<h3 id="HTTP-x2F-1-1"><a href="#HTTP-x2F-1-1" class="headerlink" title="HTTP&#x2F;1.1"></a>HTTP&#x2F;1.1</h3><h4 id="HTTP-x2F-1-1优点"><a href="#HTTP-x2F-1-1优点" class="headerlink" title="HTTP&#x2F;1.1优点"></a>HTTP&#x2F;1.1优点</h4><p>​		HTTP&#x2F;1.1 最凸出的优点是「简单、灵活和易于扩展、应用广泛和跨平台」</p>
<ol>
<li>简单</li>
</ol>
<p>​		HTTP 基本的报文格式就是 <code>header + body</code>，头部信息也是 <code>key-value</code> 简单文本的形式，<strong>易于理解</strong>，降低了学习和使用的门槛。</p>
<ol start="2">
<li>灵活和易于扩展</li>
</ol>
<p>​		HTTP 协议里的各类请求方法、URI&#x2F;URL、状态码、头字段等每个组成要求都没有被固定死，都允许开发人员<strong>自定义和扩充</strong>。</p>
<p>​		同时 HTTP 由于是工作在应用层（ <code>OSI</code> 第七层），则它<strong>下层可以随意变化</strong>，比如：</p>
<ul>
<li>HTTPS 就是在 HTTP 与 TCP 层之间增加了 SSL&#x2F;TLS 安全传输层；</li>
<li>HTTP&#x2F;1.1 和 HTTP&#x2F;2.0 传输协议使用的是 TCP 协议，而到了 HTTP&#x2F;3.0 传输协议改用了 UDP 协议。</li>
</ul>
<ol start="3">
<li>应用广泛和跨平台</li>
</ol>
<p>​		互联网发展至今，HTTP 的应用范围非常的广泛，从台式机的浏览器到手机上的各种 APP，从看新闻、刷贴吧到购物、理财、吃鸡，HTTP 的应用遍地开花，具有<strong>跨平台</strong>的优越性。</p>
<h4 id="HTTP-x2F-1-1缺点"><a href="#HTTP-x2F-1-1缺点" class="headerlink" title="HTTP&#x2F;1.1缺点"></a>HTTP&#x2F;1.1缺点</h4><p>​		HTTP&#x2F;1.1 里有优缺一体的<strong>双刃剑</strong>，分别是「无状态、明文传输」，同时还有一大缺点「不安全」</p>
<ol>
<li>无状态双刃剑</li>
</ol>
<p>​		无状态的<strong>好处</strong>，因为服务器不会去记忆 HTTP 的状态，所以不需要额外的资源来记录状态信息，这能减轻服务器的负担，能够把更多的 CPU 和内存用来对外提供服务。</p>
<p>​		无状态的<strong>坏处</strong>，既然服务器没有记忆能力，它在完成有关联性的操作时会非常麻烦。</p>
<p>​		对于无状态的问题，解法方案有很多种，其中比较简单的方式用 <strong>Cookie</strong> 技术。<code>Cookie</code> 通过在请求和响应报文中写入 Cookie 信息来控制客户端的状态。</p>
<p>​		相当于，<strong>在客户端第一次请求后，服务器会下发一个装有客户信息的「小贴纸」，后续客户端请求服务器的时候，带上「小贴纸」，服务器就能认得了了</strong>。</p>
<img src="https://s2.loli.net/2023/01/11/WzBV3UyTPEmIbjv.png" alt="Cookie 技术" style="zoom:67%;" />

<ol start="2">
<li>明文传输双刃剑</li>
</ol>
<p>​		明文意味着在传输过程中的信息，是可方便阅读的，但是这正是这样，HTTP 的所有信息都暴露在了光天化日下，相当于<strong>信息裸奔</strong>。在传输的漫长的过程中，信息的内容都毫无隐私可言，很容易就能被窃取，如果里面有你的账号密码信息，那<strong>你号没了</strong>。</p>
<ol start="3">
<li>不安全</li>
</ol>
<p>​		HTTP 比较严重的缺点就是不安全：</p>
<ul>
<li>通信使用明文（不加密），内容可能会被窃听。比如，<strong>账号信息容易泄漏，那你号没了。</strong></li>
<li>不验证通信方的身份，因此有可能遭遇伪装。比如，<strong>访问假的淘宝、拼多多，那你钱没了。</strong></li>
<li>无法证明报文的完整性，所以有可能已遭篡改。比如，<strong>网页上植入垃圾广告，视觉污染，眼没了。</strong></li>
</ul>
<p>​		HTTP 的安全问题，可以用 HTTPS 的方式解决，也就是通过引入 <strong>SSL&#x2F;TLS 层</strong>，使得在安全上达到了极致。</p>
<h4 id="HTTP-x2F-1-1性能"><a href="#HTTP-x2F-1-1性能" class="headerlink" title="HTTP&#x2F;1.1性能"></a>HTTP&#x2F;1.1性能</h4><p>​		HTTP&#x2F;1.1 是基于 <strong>TCP&#x2F;IP</strong>，并且使用了「<strong>请求 - 应答</strong>」的通信模式，HTTP&#x2F;1.1 相比 HTTP&#x2F;1.0 性能上的改进关键就在 <strong>长连接</strong> 和 <strong>管道网络运输</strong> 这两点里。</p>
<ul>
<li>使用长连接的方式改善了 HTTP&#x2F;1.0 短连接造成的性能开销。</li>
<li>支持管道（pipeline）网络传输，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。</li>
</ul>
<ol>
<li>长连接</li>
</ol>
<p>​		 HTTP&#x2F;1.0 性能上的一个很大的问题，那就是每发起一个请求，都要新建一次 TCP 连接（三次握手），而且是串行请求，做了无谓的 TCP 连接建立和断开，增加了通信开销。</p>
<img src="https://s2.loli.net/2023/01/11/ml8jwAJIiPRSGfs.png" alt="短连接与长连接" style="zoom: 80%;" />

<p>​		为了解决上述 TCP 连接问题，HTTP&#x2F;1.1 提出了<strong>长连接</strong>的通信方式，也叫持久连接。这种方式的好处在于减少了 TCP 连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载。</p>
<p>​		持久连接的特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。当然，如果某个 HTTP 长连接超过一定时间没有任何数据交互，服务端就会主动断开这个连接。</p>
<ol start="2">
<li>管道网络传输</li>
</ol>
<p>​		HTTP&#x2F;1.1 采用了长连接的方式，这使得管道（pipeline）网络传输成为了可能。即可在同一个 TCP 连接里面，客户端可以发起多个请求，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以<strong>减少整体的响应时间。</strong></p>
<img src="https://s2.loli.net/2023/01/11/MOT3kbBSqlnjZCA.png" alt="管道网络传输" style="zoom:80%;" />

<p>​		但是<strong>服务器必须按照接收请求的顺序发送对这些管道化请求的响应</strong> ：如果服务端在处理 A 请求时耗时比较长，那么后续的请求的处理都会被阻塞住，这称为「队头堵塞」。</p>
<p>​		简而言之，<strong>HTTP&#x2F;1.1 管道解决了请求的队头阻塞，但是没有解决响应的队头阻塞</strong>。</p>
<ol start="3">
<li>队头阻塞</li>
</ol>
<p>​		「请求 - 应答」的模式加剧了 HTTP 的性能问题。因为当顺序发送的请求序列中的一个请求因为某种原因被阻塞时，在后面排队的所有请求也一同被阻塞了，会招致客户端一直请求不到数据，这也就是「<strong>队头阻塞</strong>」，好比上班的路上塞车。</p>
<img src="https://s2.loli.net/2023/01/11/pwElBKg5szDMAFd.png" alt="队头阻塞" style="zoom: 80%;" />

<h4 id="HTTP-x2F-1-1-协议优化思路"><a href="#HTTP-x2F-1-1-协议优化思路" class="headerlink" title="HTTP&#x2F;1.1 协议优化思路"></a>HTTP&#x2F;1.1 协议优化思路</h4><p>​		第一个思路是，通过<strong>缓存技术</strong>来避免发送 HTTP 请求。客户端收到第一个请求的响应后，可以将其缓存在本地磁盘，下次请求的时候，如果缓存没过期，就直接读取本地缓存的响应数据。如果缓存过期，客户端发送请求的时候带上响应数据的摘要，服务器比对后发现资源没有变化，就发出不带包体的 304 响应，告诉客户端缓存的响应仍然有效。</p>
<p>​		第二个思路是，<strong>减少 HTTP 请求</strong>的次数，有以下的方法：</p>
<ol>
<li>将原本由客户端处理的重定向请求，交给代理服务器处理，这样可以减少重定向请求的次数；</li>
<li>将多个小资源合并成一个大资源再传输，能够减少 HTTP 请求次数以及 头部的重复传输，再来减少 TCP 连接数量，进而省去 TCP 握手和慢启动的网络消耗；</li>
<li>按需访问资源，只访问当前用户看得到&#x2F;用得到的资源，当客户往下滑动，再访问接下来的资源，以此达到延迟请求，也就减少了同一时间的 HTTP 请求次数。</li>
</ol>
<p>​		第三思路是，通过<strong>压缩响应资源，降低传输资源的大小</strong>，从而提高传输效率，所以应当选择更优秀的压缩算法。</p>
<h3 id="HTTP-x2F-2"><a href="#HTTP-x2F-2" class="headerlink" title="HTTP&#x2F;2"></a>HTTP&#x2F;2</h3><p>​		HTTP&#x2F;2 协议是基于 HTTPS 的，所以 HTTP&#x2F;2 的安全性也是有保障的。</p>
<img src="https://s2.loli.net/2023/01/11/Y3uZCPXymIGM4nx.jpg" alt="HTT/1 ~ HTTP/2" style="zoom:80%;" />

<h4 id="HTTP-x2F-2性能"><a href="#HTTP-x2F-2性能" class="headerlink" title="HTTP&#x2F;2性能"></a>HTTP&#x2F;2性能</h4><p>​		HTTP&#x2F;2 相比 HTTP&#x2F;1.1 以下性能上的改进：</p>
<ol>
<li>头部压缩</li>
</ol>
<p>​		HTTP&#x2F;2 会<strong>压缩头</strong>（Header）。如果你同时发出多个请求，他们的头是一样的或是相似的，那么，协议会帮你<strong>消除重复的部分</strong>。这就是所谓的 <code>HPACK</code> 算法：在客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，以此<strong>提高访问速度</strong></p>
<ol start="2">
<li>二进制帧</li>
</ol>
<p>​		HTTP&#x2F;2 不再像 HTTP&#x2F;1.1 里的纯文本形式的报文，而是全面采用了<strong>二进制格式</strong>，头信息和数据体都是二进制，并且统称为帧（frame）：<strong>头信息帧（Headers Frame）和数据帧（Data Frame）</strong>。</p>
<p>​		计算机可以直接解析二进制报文，<strong>增加了数据传输的效率</strong>。</p>
<ol start="3">
<li>并发传输</li>
</ol>
<p>​		HTTP&#x2F;1.1 的实现是基于请求-响应模型的。同一个连接中，HTTP 完成一个事务（请求与响应），才能处理下一个事务，也就是说在发出请求等待响应的过程中，是没办法做其他事情的，如果响应迟迟不来，那么后续的请求是无法发送的，也造成了<strong>队头阻塞</strong>的问题。</p>
<p>​		而 HTTP&#x2F;2 引出了 Stream 概念，多个 Stream 复用在一条 TCP 连接。Stream 里可以包含 1 个或多个 Message，<strong>Message 对应 HTTP&#x2F;1 中的请求或响应</strong>，由 HTTP 头部和包体构成。Message 里包含一条或者多个 Frame，<strong>Frame 是 HTTP&#x2F;2 最小单位，以二进制压缩格式存放 HTTP&#x2F;1 中的内容（头部和包体）</strong>。</p>
<img src="https://s2.loli.net/2023/01/11/3dPu74I5HVkcOep.png" alt="img" style="zoom:67%;" />

<p>​		针对不同的 HTTP 请求用独一无二的 Stream ID 来区分，接收端可以通过 Stream ID 有序组装成 HTTP 消息，不同 Stream 的帧是可以乱序发送的，因此可以并发不同的 Stream ，也就是 <strong>HTTP&#x2F;2 可以并行交错地发送请求和响应</strong>。</p>
<blockquote>
<p>服务端<strong>并行交错地</strong>发送了两个响应： Stream 1 和 Stream 3，这两个 Stream 都是跑在一个 TCP 连接上，客户端收到后，会根据相同的 Stream ID 有序组装成 HTTP 消息。</p>
</blockquote>
<img src="https://s2.loli.net/2023/01/11/bTYMOk2BnsGlIDV.jpg" alt="img" style="zoom:67%;" />

<ol start="4">
<li>服务器主动推送</li>
</ol>
<p>​		HTTP&#x2F;2 改善了传统的「请求 - 应答」工作模式，服务端不再是被动地响应，可以<strong>主动</strong>向客户端发送消息。</p>
<p>​		客户端和服务器<strong>双方都可以建立 Stream</strong>， Stream ID 也是有区别的，客户端建立的 Stream 必须是奇数号，而服务器建立的 Stream 必须是偶数号。</p>
<blockquote>
<p>Stream 1 是客户端向服务端请求的资源，属于客户端建立的 Stream，所以该 Stream 的 ID 是奇数（数字1）；Stream 2 和 4 都是服务端主动向客户端推送的资源，属于服务端建立的 Stream，所以这两个 Stream 的 ID 是偶数（数字 2 和4）</p>
</blockquote>
<img src="https://s2.loli.net/2023/01/11/mOt4VZlrBqIf1xD.png" alt="img" style="zoom: 33%;" />

<p>​		客户端通过 HTTP&#x2F;1.1 请求从服务器那获取到了 HTML 文件，而 HTML 可能还需要依赖 CSS 来渲染页面，这时客户端还要再发起获取 CSS 文件的请求，需要两次消息往返，如下图左边部分：</p>
<img src="https://s2.loli.net/2023/01/11/rT1a27HYJfXOCdu.png" alt="img" style="zoom:67%;" />

<p>​		在 HTTP&#x2F;2 中，如上图右边部分，客户端在访问 HTML 时，服务器可以直接主动推送 CSS 文件，减少了消息传递的次数。</p>
<h4 id="HTTP-x2F-2缺点"><a href="#HTTP-x2F-2缺点" class="headerlink" title="HTTP&#x2F;2缺点"></a>HTTP&#x2F;2缺点</h4><p>​		HTTP&#x2F;2 通过 Stream 的并发能力，解决了 HTTP&#x2F;1 队头阻塞的问题，但还是存在“队头阻塞”的问题，只不过问题不是在 HTTP 这一层面，而是在 TCP 这一层。</p>
<p>​		HTTP&#x2F;2 是基于 <strong>TCP 协议</strong> 来传输数据的，TCP 是字节流协议，TCP 层必须保证收到的字节数据是完整且连续的，这样内核才会将缓冲区里的数据返回给 HTTP 应用，那么当「前 1 个字节数据」没有到达时，后收到的字节数据只能存放在内核缓冲区里，只有等到这 1 个字节数据到达时，HTTP&#x2F;2 应用层才能从内核中拿到数据，这就是 HTTP&#x2F;2 队头阻塞问题。</p>
<img src="https://s2.loli.net/2023/01/11/XwPfjQ8a6DvpS7l.jpg" alt="img" style="zoom: 50%;" />

<p>​		举个例子：</p>
<img src="https://s2.loli.net/2023/01/11/p8rCbu9aAKHn5JD.gif" alt="img" style="zoom:67%;" />

<p>​		图中发送方发送了很多个 packet，每个 packet 都有自己的序号，可以认为是 TCP 的序列号，其中 packet 3 在网络中丢失了，即使 packet 4-6 被接收方收到后，由于内核中的 TCP 数据不是连续的，于是接收方的应用层就无法从内核中读取到，只有等到 packet 3 重传后，接收方的应用层才可以从内核中读取到数据，这就是 HTTP&#x2F;2 的队头阻塞问题，是在 TCP 层面发生的。</p>
<p>​		所以，一旦发生了丢包现象，就会触发 TCP 的重传机制，这样在一个 TCP 连接中的<strong>所有的 HTTP 请求都必须等待这个丢了的包被重传回来</strong>。</p>
<h3 id="HTTP-x2F-3"><a href="#HTTP-x2F-3" class="headerlink" title="HTTP&#x2F;3"></a>HTTP&#x2F;3</h3><h4 id="HTTP-x2F-3性能"><a href="#HTTP-x2F-3性能" class="headerlink" title="HTTP&#x2F;3性能"></a>HTTP&#x2F;3性能</h4><p>​		我们知道了 HTTP&#x2F;1.1 和 HTTP&#x2F;2 都有队头阻塞的问题：</p>
<ul>
<li>HTTP&#x2F;1.1 中的管道（ pipeline）虽然解决了请求的队头阻塞，但是<strong>没有解决响应的队头阻塞</strong>，因为服务端需要按顺序响应收到的请求，如果服务端处理某个请求消耗的时间比较长，那么只能等响应完这个请求后， 才能处理下一个请求，这属于 HTTP 层队头阻塞。</li>
<li>HTTP&#x2F;2 虽然通过多个请求复用一个 TCP 连接解决了 HTTP 的队头阻塞 ，但是<strong>一旦发生丢包，就会阻塞住所有的 HTTP 请求</strong>，这属于 TCP 层队头阻塞。</li>
</ul>
<p>​		我们知道，HTTP&#x2F;2 的队头阻塞是由于 <strong>TCP协议</strong>  的性质导致的，所以 <strong>HTTP&#x2F;3 把 HTTP 下层的 TCP 协议改成了 UDP！</strong></p>
<img src="https://s2.loli.net/2023/01/11/eBKlYju7ysCR1D5.jpg" alt="HTTP/1 ~ HTTP/3" style="zoom:67%;" />



<p>​		UDP本身是不可靠的，它的发送不会管顺序和是否丢包，所以不存在队头阻塞的问题。但通过UDP的 <strong>QUIC 协议</strong> 可以使UDP实现类似TCP的可靠性传输。</p>
<h4 id="QUIC协议"><a href="#QUIC协议" class="headerlink" title="QUIC协议"></a>QUIC协议</h4><ul>
<li>无队头阻塞</li>
<li>更快的连接建立</li>
<li>连接迁移</li>
</ul>
<ol>
<li>无队头阻塞</li>
</ol>
<p>​		QUIC 协议也有类似 HTTP&#x2F;2 Stream 与多路复用的概念，也是可以在同一条连接上并发传输多个 Stream，Stream 可以认为就是一条 HTTP 请求。</p>
<p>​		QUIC 有自己的一套机制可以保证传输的可靠性的。<strong>当某个流发生丢包时，只会阻塞这个流，其他流不会受到影响，因此不存在队头阻塞问题</strong>。这与 HTTP&#x2F;2 不同，HTTP&#x2F;2 只要某个流中的数据包丢失了，其他流也会因此受影响。</p>
<p>​		所以，QUIC 连接上的多个 Stream 之间并没有依赖，都是独立的，某个流发生丢包了，只会影响该流，其他流不受影响。</p>
<img src="https://s2.loli.net/2023/01/11/HcJmh7ZFsWPyxLg.jpg" alt="img" style="zoom: 50%;" />

<ol start="2">
<li>更快的连接建立</li>
</ol>
<p>​		对于 HTTP&#x2F;1 和 HTTP&#x2F;2 协议，TCP 和 TLS 是分层的，分别属于内核实现的传输层、openssl 库实现的表示层，因此它们难以合并在一起，需要分批次来握手，先 TCP 握手，再 TLS 握手。</p>
<p>​		HTTP&#x2F;3 在传输数据前虽然需要 QUIC 协议握手，这个握手过程只需要 1 RTT，握手的目的是为确认双方的「连接 ID」，连接迁移就是基于连接 ID 实现的。但是 HTTP&#x2F;3 的 QUIC 协议并不是与 TLS 分层，而是<strong>QUIC 内部包含了 TLS</strong>，它在自己的帧会携带 TLS 里的“记录”，再加上 <strong>QUIC 使用的是 TLS&#x2F;1.3</strong>，因此仅需 1 个 RTT 就可以「同时」完成建立连接与密钥协商</p>
<img src="https://s2.loli.net/2023/01/11/o1UDNLRIcdJ6VOA.jpg" alt="TCP HTTPS（TLS/1.3） 和 QUIC HTTPS " style="zoom: 67%;" />

<p>​		甚至在第二次连接的时候，应用数据包可以和 QUIC 握手信息（连接信息 + TLS 信息）一起发送，达到 0-RTT 的效果。</p>
<img src="https://s2.loli.net/2023/01/11/pIsmXZnwjMkvzUh.png" alt="img" style="zoom: 50%;" />

<ol start="3">
<li>连接迁移</li>
</ol>
<p>​		基于 TCP 传输协议的 HTTP 协议，由于是通过<strong>四元组（源 IP、源端口、目的 IP、目的端口）</strong>确定一条 TCP 连接。</p>
<p>​		那么<strong>当移动设备的网络从 4G 切换到 WIFI 时，意味着 IP 地址变化了，那么就必须要断开连接，然后重新建立连接</strong>。而建立连接的过程包含 <strong>TCP 三次握手和 TLS 四次握手</strong>的时延，以及 TCP 慢启动的减速过程，给用户的感觉就是网络突然卡顿了一下，因此连接的迁移成本是很高的。</p>
<p>​		而 QUIC 协议没有用四元组的方式来“绑定”连接，而是通过<strong>连接 ID</strong>来标记通信的两个端点，客户端和服务器可以各自选择一组 ID 来标记自己，因此即使移动设备的网络变化后，导致 IP 地址变化了，只要仍保有<strong>上下文信息</strong>（比如连接 ID、TLS 密钥等），就可以“无缝”地复用原连接，消除重连的成本，没有丝毫卡顿感，达到了<strong>连接迁移</strong>的功能。</p>
<p>​		所以， QUIC 是一个在 UDP 之上的<strong>伪</strong> TCP + TLS + HTTP&#x2F;2 的多路复用的协议。</p>
<hr>
<h2 id="HTTPS概念"><a href="#HTTPS概念" class="headerlink" title="HTTPS概念"></a>HTTPS概念</h2><h3 id="HTTP-与-HTTPS-有哪些区别？"><a href="#HTTP-与-HTTPS-有哪些区别？" class="headerlink" title="HTTP 与 HTTPS 有哪些区别？"></a>HTTP 与 HTTPS 有哪些区别？</h3><ul>
<li>HTTP 是<strong>超文本传输协议</strong>，信息是<strong>明文</strong>传输，存在安全风险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在 TCP 和 HTTP 网络层之间加入了 <strong>SSL&#x2F;TLS 安全协议</strong>，使得报文能够加密传输。</li>
<li>HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 在 <strong>TCP 三次握手之后，还需进行 SSL&#x2F;TLS 的握手过程</strong>，才可进入加密报文传输。</li>
<li>两者的默认端口不一样，HTTP 默认端口号是 80，HTTPS 默认端口号是 443。</li>
<li>HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。</li>
</ul>
<h3 id="HTTPS-解决了-HTTP-的哪些问题？"><a href="#HTTPS-解决了-HTTP-的哪些问题？" class="headerlink" title="HTTPS 解决了 HTTP 的哪些问题？"></a>HTTPS 解决了 HTTP 的哪些问题？</h3><p>​		HTTP 由于是明文传输，所以安全上存在以下三个风险：</p>
<ul>
<li><strong>窃听风险</strong>，比如通信链路上可以获取通信内容，用户号容易没。</li>
<li><strong>篡改风险</strong>，比如强制植入垃圾广告，视觉污染，用户眼容易瞎。</li>
<li><strong>冒充风险</strong>，比如冒充淘宝网站，用户钱容易没。</li>
</ul>
<p>​		HTTP<strong>S</strong> 在 HTTP 与 TCP 层之间加入了 <code>SSL/TLS</code> 协议，可以很好的解决了上述的风险：</p>
<img src="https://s2.loli.net/2023/01/11/9iodNQ5m14twhgX.jpg" alt="HTTP 与 HTTPS 网络层" style="zoom: 67%;" />

<ul>
<li><strong>混合加密</strong>的方式实现信息的<strong>机密性</strong>，解决了窃听的风险。</li>
<li><strong>摘要算法</strong>的方式来实现<strong>完整性</strong>，它能够为数据生成独一无二的「指纹」，指纹用于校验数据的完整性，解决了篡改的风险。</li>
<li>将服务器公钥放入到<strong>数字证书</strong>中，解决了冒充的风险。</li>
</ul>
<p>​		可以说，只要自身不做「恶」，<strong>SSL&#x2F;TLS 协议是能保证通信是安全的</strong>。</p>
<h3 id="HTTPS通信流程"><a href="#HTTPS通信流程" class="headerlink" title="HTTPS通信流程"></a>HTTPS通信流程</h3><ol>
<li>客户端要访问一个网站，向支持https的服务器发起请求。</li>
<li>客户端向服务器发送自己支持的秘钥交换算法列表。</li>
<li>服务器选取一种秘钥交换算法加上CA证书返回给客户端。</li>
<li>客户端验证服务器是否合法，并生成一个随机数然后用协商好的加密算法加密生成随机秘钥，并用刚才从CA证书中拿到的公钥对其加密后发送给服务器。</li>
<li>服务器收到后用自己的私钥解密</li>
<li>服务器私钥解密之后，拿到对称秘钥，并且用它再加密一个信息，返回给浏览器。</li>
</ol>
<img src="https://s2.loli.net/2023/01/10/ji2CcQuroF4zHDq.png" alt="image.png" style="zoom:80%;" />

<h2 id="HTTPS-升级优化"><a href="#HTTPS-升级优化" class="headerlink" title="HTTPS 升级优化"></a>HTTPS 升级优化</h2><p>​		HTTPS 相比 HTTP 协议多一个 TLS 协议握手过程，<strong>目的是为了通过非对称加密握手协商或者交换出对称加密密钥</strong>，这个过程最长可以花费掉 2 RTT，接着后续传输的应用数据都得使用对称加密密钥来加密&#x2F;解密。</p>
<h3 id="分析性能损耗"><a href="#分析性能损耗" class="headerlink" title="分析性能损耗"></a>分析性能损耗</h3><p>​		要对 HTTPS 优化，首先得清楚哪些步骤会产生性能消耗，再对症下药。</p>
<p>​		产生性能消耗的两个环节：</p>
<ul>
<li>第一个环节， TLS 协议握手过程；</li>
<li>第二个环节，握手后的对称加密报文传输。</li>
</ul>
<p>​		对于第二环节，现在主流的对称加密算法 AES、ChaCha20 性能都是不错的，而且一些 CPU 厂商还针对它们做了硬件级别的优化，因此这个环节的性能消耗可以说非常地小。</p>
<p>​		而第一个环节，TLS 协议握手过程不仅增加了网络延时（最长可以花费掉 2 RTT），而且握手过程中的一些步骤也会产生性能损耗，比如：</p>
<ul>
<li>对于 ECDHE 密钥协商算法，握手过程中客户端和服务端都需要临时生成椭圆曲线公私钥；</li>
<li>客户端验证证书时，会访问 CA 获取 CRL 或者 OCSP，目的是验证服务器的证书是否有被吊销；</li>
<li>双方计算 Pre-Master，也就是对称加密密钥；</li>
</ul>
<img src="https://s2.loli.net/2023/01/12/szU3bWiwcQpRq2L.png" alt="img" style="zoom: 67%;" />

<h3 id="硬件优化"><a href="#硬件优化" class="headerlink" title="硬件优化"></a>硬件优化</h3><p>​		<strong>HTTPS 协议是计算密集型，而不是 I&#x2F;O 密集型</strong>，所以不能把钱花在网卡、硬盘等地方，应该花在 CPU 上。一个好的 CPU，可以提高计算性能，因为 HTTPS 连接过程中就有大量需要计算密钥的过程，所以这样可以加速 TLS 握手过程。</p>
<p>​		另外，最好选择可以<strong>支持 AES-NI 特性的 CPU</strong>，因为这种款式的 CPU 能在指令级别优化了 AES 算法，这样便加速了数据的加解密传输过程。</p>
<h3 id="软件优化"><a href="#软件优化" class="headerlink" title="软件优化"></a>软件优化</h3><p>​		软件的优化方向可以分层两种，一个是<strong>软件升级</strong>，一个是<strong>协议优化</strong>。</p>
<p>​		由于软件升级容易导致版本兼容问题，所以主要考虑协议优化。</p>
<h4 id="协议优化"><a href="#协议优化" class="headerlink" title="协议优化"></a>协议优化</h4><p>​		协议的优化就是对「密钥交换过程」进行优化。</p>
<h5 id="密钥交换算法优化"><a href="#密钥交换算法优化" class="headerlink" title="密钥交换算法优化"></a>密钥交换算法优化</h5><p>​		TLS 1.2 版本如果使用的是 RSA 密钥交换算法，那么需要 4 次握手，也就是要花费 2 RTT，才可以进行应用数据的传输，而且 RSA 密钥交换算法不具备前向安全性。一句话概括就是： <strong>RSA 密钥交换算法的 TLS 握手过程，不仅慢，而且安全性也不高</strong>。</p>
<p>​		因此尽量<strong>选用 ECDHE 密钥交换</strong>算法替换 RSA 算法，因为该算法由于支持「False Start」，它是“抢跑”的意思，客户端可以在 TLS 协议的第 3 次握手后，第 4 次握手前，发送加密的应用数据，以此将 <strong>TLS 握手的消息往返由 2 RTT 减少到 1 RTT，而且安全性也高，具备前向安全性</strong>。</p>
<p>​		ECDHE 算法是基于椭圆曲线实现的，不同的椭圆曲线性能也不同，应该尽量<strong>选择 x25519 曲线</strong>，该曲线是目前最快的椭圆曲线。</p>
<p>​		对于对称加密算法方面，如果对安全性不是特别高的要求，可以<strong>选用 AES_128_GCM</strong>，它比 AES_256_GCM 快一些，因为密钥的长度短一些。</p>
<h4 id="TLS-升级"><a href="#TLS-升级" class="headerlink" title="TLS 升级"></a>TLS 升级</h4><p>​		当然，如果直接把 TLS 1.2 升级成 TLS 1.3，TLS 1.3 大幅度简化了握手的步骤，<strong>完成 TLS 握手只要 1 RTT</strong>，而且安全性更高。</p>
<h3 id="证书优化"><a href="#证书优化" class="headerlink" title="证书优化"></a>证书优化</h3><p>​		为了验证的服务器的身份，服务器会在 TLS 握手过程中，把自己的证书发给客户端，以此证明自己身份是可信的。</p>
<p>​		对于证书的优化，可以有两个方向：</p>
<ul>
<li>一个是<strong>证书传输</strong>，</li>
<li>一个是<strong>证书验证</strong>；</li>
</ul>
<h4 id="证书传输优化"><a href="#证书传输优化" class="headerlink" title="证书传输优化"></a>证书传输优化</h4><p>​		要让证书更便于传输，那必然是减少证书的大小，这样可以节约带宽，也能减少客户端的运算量。所以，<strong>对于服务器的证书应该选择椭圆曲线（ECDSA）证书，而不是 RSA 证书，因为在相同安全强度下， ECC 密钥长度比 RSA 短的多</strong>。</p>
<h4 id="证书验证优化"><a href="#证书验证优化" class="headerlink" title="证书验证优化"></a>证书验证优化</h4><p>​		客户端在验证证书时，是个复杂的过程，会走证书链逐级验证，验证的过程不仅需要「用 CA 公钥解密证书」以及「用签名算法验证证书的完整性」，而且为了知道证书是否被 CA 吊销，客户端有时还会再去访问 CA， 下载 CRL 或者 OCSP 数据，以此确认证书的有效性。</p>
<p>​		这个访问过程是 HTTP 访问，因此又会产生一系列网络通信的开销，如 DNS 查询、建立连接、收发数据等。</p>
<h4 id="特有名词释义"><a href="#特有名词释义" class="headerlink" title="特有名词释义"></a>特有名词释义</h4><p><strong>CRL</strong></p>
<p>​		CRL 称为证书吊销列表（<em>Certificate Revocation List</em>），这个列表是由 CA 定期更新，列表内容都是被撤销信任的证书序号，如果服务器的证书在此列表，就认为证书已经失效，不在的话，则认为证书是有效的。</p>
<img src="https://s2.loli.net/2023/01/12/eCaz7W4kcENHqDP.png" style="zoom:80%;" />

<p>​		但是 CRL 存在两个问题：</p>
<ul>
<li><p>第一个问题，由于 CRL 列表是由 CA 维护的，定期更新，如果一个证书刚被吊销后，客户端在更新 CRL 之前还是会信任这个证书，<strong>实时性较差</strong>；</p>
</li>
<li><p>第二个问题，<strong>随着吊销证书的增多，列表会越来越大，下载的速度就会越慢</strong>，下载完客户端还得遍历这么大的列表，那么就会导致客户端在校验证书这一环节的延时很大，进而拖慢了 HTTPS 连接。</p>
<p>因此，现在基本都是使用 OCSP</p>
</li>
</ul>
<p><strong>OCSP</strong></p>
<p>​		OCSP 名为在线证书状态协议（<em>Online Certificate Status Protocol</em>）主要用来查询证书的有效性，它的工作方式是<strong>向 CA 发送查询请求，让 CA 返回证书的有效状态</strong>。</p>
<img src="https://s2.loli.net/2023/01/12/sUNLjKOyuSwmJ9M.png" style="zoom:80%;" />

<p>​		OCSP不必像 CRL 方式客户端需要下载大大的列表，还要从列表查询，同时因为可以实时查询每一张证书的有效性，解决了 CRL 的实时性问题。但 OCSP 仍需要向 CA 查询，因此也是要发生网络请求，而且还得看 CA 服务器的“脸色”，如果网络状态不好，或者 CA 服务器繁忙，也会导致客户端在校验证书这一环节的延时变大。</p>
<p>​		为了解决这一个网络开销，就出现了 OCSP Stapling</p>
<p><strong>OCSP Stapling</strong></p>
<p>​		OCSP Stapling 其原理是：服务器向 CA 周期性地查询证书状态，获得一个带有时间戳和签名的响应结果并缓存它。</p>
<p><img src="https://s2.loli.net/2023/01/12/CcLfHSzsImOXhre.png"></p>
<p>​		当有客户端发起连接请求时，服务器会把这个「响应结果」在 TLS 握手过程中发给客户端。由于有签名的存在，服务器无法篡改，因此客户端就能得知证书是否已被吊销了，这样客户端就不需要再去查询。</p>
<h3 id="会话复用"><a href="#会话复用" class="headerlink" title="会话复用"></a>会话复用</h3><p>​		TLS 握手的目的就是为了<strong>协商会话密钥</strong>，也就是对称加密密钥，那如果把首次 TLS 握手协商的对称加密密钥缓存起来，待下次需要建立 HTTPS 连接时，直接「复用」这个密钥，不就减少 TLS 握手的性能损耗了吗？</p>
<p>​		这种方式就是<strong>会话复用</strong>（<em>TLS session resumption</em>），会话复用分两种：</p>
<ul>
<li>第一种叫 Session ID；</li>
<li>第二种叫 Session Ticket；</li>
</ul>
<h4 id="Session-ID"><a href="#Session-ID" class="headerlink" title="Session ID"></a>Session ID</h4><p>​		Session ID 的工作原理是，<strong>客户端和服务器首次 TLS 握手连接后，双方会在内存缓存会话密钥，并用唯一的 Session ID 来标识</strong>，Session ID 和会话密钥相当于 key-value 的关系。</p>
<p>​		当客户端再次连接时，hello 消息里会带上 Session ID，服务器收到后就会从内存找，如果找到就直接用该会话密钥恢复会话状态，跳过其余的过程，只用一个消息往返就可以建立安全通信。当然为了安全性，内存中的会话密钥会定期失效。</p>
<img src="https://s2.loli.net/2023/01/13/5nxrh63jwdcGLRC.png" style="zoom:67%;" />

<p>​		Session ID有两个缺点：</p>
<ul>
<li>服务器必须保持每一个客户端的会话密钥，随着客户端的增多，<strong>服务器的内存压力也会越大</strong>。</li>
<li>现在网站服务一般是由多台服务器通过负载均衡提供服务的，<strong>客户端再次连接不一定会命中上次访问过的服务器</strong>，于是还要走完整的 TLS 握手过程；</li>
</ul>
<p>​		为了解决 Session ID 的问题，就出现了 Session Ticket</p>
<h4 id="Session-Ticket"><a href="#Session-Ticket" class="headerlink" title="Session Ticket"></a>Session Ticket</h4><p>​		Session Ticket使 <strong>服务器不再缓存每个客户端的会话密钥，而是把缓存的工作交给了客户端</strong>，类似于 HTTP 的 Cookie。</p>
<p>​		客户端与服务器首次建立连接时，服务器会加密「会话密钥」作为 Ticket 发给客户端，交给客户端缓存该 Ticket。</p>
<p>​		客户端再次连接服务器时，客户端会发送 Ticket，服务器解密后就可以获取上一次的会话密钥，然后验证有效期，如果没问题，就可以恢复会话，开始加密通信。</p>
<img src="https://s2.loli.net/2023/01/13/MgFhUKxvELIYk1C.png" style="zoom:67%;" />

<p>​		对于集群服务器的话，<strong>要确保每台服务器加密 「会话密钥」的密钥是一致的</strong>，这样客户端携带 Ticket 访问任意一台服务器时，都能恢复会话。</p>
<blockquote>
<p><strong>为什么要给会话密钥设定一个合理的过期时间？</strong></p>
</blockquote>
<p>​		Session ID 和 Session Ticket <strong>都不具备前向安全性</strong>，一旦加密「会话密钥」的密钥被破解或者服务器泄漏「会话密钥」，前面劫持的通信密文都会被破解。</p>
<h4 id="重放攻击"><a href="#重放攻击" class="headerlink" title="重放攻击"></a>重放攻击</h4><p>​		重放攻击是一种中间人攻击，重放攻击的危险之处在于，如果中间人截获了某个客户端的 Session ID 或 Session Ticket 以及 POST 报文，而一般 POST 请求会改变数据库的数据，重（chong）放的意思就是：中间人可以利用此截获的报文，不断向服务器发送该报文，这样就会导致数据库的数据被中间人改变了，而客户是不知情的。</p>
<img src="https://s2.loli.net/2023/01/13/HOFAYd5cyuJPz3D.png" alt="img" style="zoom: 67%;" />

<blockquote>
<p>假设 Alice 想向 Bob 证明自己的身份。 Bob 要求 Alice 的密码作为身份证明，爱丽丝应尽全力提供（可能是在经过如哈希函数的转换之后）。与此同时，Eve 窃听了对话并保留了密码（或哈希）。交换结束后，Eve（冒充 Alice ）连接到 Bob。当被要求提供身份证明时，Eve 发送从 Bob 接受的最后一个会话中读取的 Alice 的密码（或哈希），从而授予 Eve 访问权限。</p>
</blockquote>
<img src="https://s2.loli.net/2023/01/13/1HCwQEq8XvbmRZI.png" alt="img" style="zoom:50%;" />

<p>​		因此，避免重放攻击的方式就是需要<strong>对会话密钥设定一个合理的过期时间</strong>，使得秘钥哪怕泄露了，影响也只是一时性的。</p>
<h4 id="Pre-shared-Key"><a href="#Pre-shared-Key" class="headerlink" title="Pre-shared Key"></a>Pre-shared Key</h4><p>​		Session ID 和 Session Ticket 方式都需要在 1 RTT 才能恢复会话。</p>
<p>​		而 TLS1.3 更为牛逼，对于重连 TLS1.3 只需要 <strong>0 RTT</strong>，原理和 Ticket 类似，只不过在重连时，客户端会把 Ticket 和 HTTP 请求一同发送给服务端，这种方式叫 <strong>Pre-shared Key</strong>。</p>
<img src="https://s2.loli.net/2023/01/13/xLHBY3E5QTDvbd4.png" alt="img" style="zoom:67%;" />

<p>​		同样的，Pre-shared Key 也有重放攻击的危险。所以，应对重放攻击可以给会话密钥设定一个合理的过期时间，以及<strong>只针对安全的 HTTP 请求如 GET&#x2F;HEAD 使用会话重用</strong>。</p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>​		对于硬件优化的方向，因为 HTTPS 是属于计算密集型，应该选择计算力更强的 CPU，而且最好选择<strong>支持 AES-NI 特性的 CPU</strong>，这个特性可以在硬件级别优化 AES 对称加密算法，加快应用数据的加解密。</p>
<p>​		对于软件优化的方向，如果可以，把软件升级成较新的版本，比如将 Linux 内核 2.X 升级成 4.X，将 openssl 1.0.1 升级到 1.1.1，因为新版本的软件不仅会提供新的特性，而且还会修复老版本的问题。</p>
<p>​		对于协议优化的方向：</p>
<ul>
<li>密钥交换算法应该选择 <strong>ECDHE 算法</strong>，而不用 RSA 算法，因为 ECDHE 算法具备前向安全性，而且客户端可以在第三次握手之后，就发送加密应用数据，节省了 1 RTT。</li>
<li>将 TLS1.2 升级 <strong>TLS1.3</strong>，因为 TLS1.3 的握手过程只需要 1 RTT，而且安全性更强。</li>
</ul>
<p>​		对于证书优化的方向：</p>
<ul>
<li>服务器应该选用 <strong>ECDSA 证书</strong>，而非 RSA 证书，因为在相同安全级别下，ECC 的密钥长度比 RSA 短很多，这样可以提高证书传输的效率；</li>
<li>服务器应该开启 <strong>OCSP Stapling</strong> 功能，由服务器预先获得 OCSP 的响应，并把响应结果缓存起来，这样 TLS 握手的时候就不用再访问 CA 服务器，减少了网络通信的开销，提高了证书验证的效率；</li>
</ul>
<p>​		对于重连 HTTPS 时，我们可以使用一些技术让客户端和服务端使用上一次 HTTPS 连接使用的会话密钥，直接恢复会话，而不用再重新走完整的 TLS 握手过程。</p>
<p>​		常见的<strong>会话重用</strong>技术有 Session ID 和 Session Ticket，用了会话重用技术，当再次重连 HTTPS 时，只需要 1 RTT 就可以恢复会话。对于 TLS1.3 使用 Pre-shared Key 会话重用技术，只需要 0 RTT 就可以恢复会话。</p>
<p>​		这些会话重用技术虽然好用，但是存在一定的安全风险，它们不仅不具备前向安全，而且有重放攻击的风险，所以应当对会话密钥设定一个合理的过期时间。</p>
<h2 id="RPC协议"><a href="#RPC协议" class="headerlink" title="RPC协议"></a>RPC协议</h2><h3 id="从-TCP-聊起"><a href="#从-TCP-聊起" class="headerlink" title="从 TCP 聊起"></a>从 TCP 聊起</h3><p>​		TCP是有三个特点，<strong>面向连接</strong>、<strong>可靠</strong>、基于<strong>字节流</strong>。一个纯裸的TCP连接，就可以做到收发数据了，那是不是就够了？不对！！！</p>
<p>​		由于 <strong>基于字节流</strong> 这一特点，纯裸TCP收发的01 串之间是<strong>没有任何边界</strong>的，你根本不知道到哪个地方才算一条完整消息。正因为这个没有<strong>任何边界</strong>的特点，所以当我们选择使用TCP发送”夏洛”和”特烦恼”的时候，接收端收到的就是”夏洛特烦恼”，这时候接收端没发区分你是想要表达”夏洛”+”特烦恼”还是”夏洛特”+”烦恼”。这就是所谓的<strong>粘包问题</strong>。</p>
<img src="https://s2.loli.net/2023/01/13/njHKIu6QD4BpaA1.png" alt="消息对比" style="zoom:67%;" />

<p>​		所以，纯裸TCP是不能直接拿来用的，需要在这个基础上加入一些<strong>自定义的规则</strong>，用于区分<strong>消息边界</strong>。于是我们会把每条要发送的数据都包装一下，比如加入<strong>消息头</strong>，<strong>消息头里写清楚一个完整的包长度是多少</strong>，根据这个长度可以继续接收数据，截取出来后它们就是我们真正要传输的<strong>消息体</strong>。</p>
<img src="https://s2.loli.net/2023/01/13/yn8dPzNTGCKZDto.png" alt="消息边界长度标志" style="zoom:67%;" />

<p>​		而这里提到的<strong>消息头</strong>，还可以放各种东西，比如消息体是否被压缩过和消息体格式之类的，只要上下游都约定好了，互相都认就可以了，这就是所谓的<strong>协议。</strong></p>
<p>​		每个使用TCP的项目都可能会定义一套类似这样的协议解析标准，他们可能<strong>有区别，但原理都类似</strong>。<strong>于是基于TCP，就衍生了非常多的协议，比如HTTP和RPC。</strong></p>
<h3 id="HTTP-和-RPC"><a href="#HTTP-和-RPC" class="headerlink" title="HTTP 和 RPC"></a>HTTP 和 RPC</h3><img src="https://s2.loli.net/2023/01/13/Cst56lVoSugeOPb.png" alt="四层网络协议" style="zoom:67%;" />

<p>​		<strong>TCP是传输层的协议</strong>，而基于TCP造出来的HTTP和<strong>各类</strong>RPC协议，它们都只是定义了不同消息格式的<strong>应用层协议</strong>而已。</p>
<p>​		<strong>HTTP</strong>协议（<strong>H</strong>yper <strong>T</strong>ext <strong>T</strong>ransfer <strong>P</strong>rotocol）又叫做<strong>超文本传输协议</strong>。我们用的比较多，平时上网在浏览器上敲个网址就能访问网页，这里用到的就是HTTP协议。</p>
<img src="https://s2.loli.net/2023/01/13/C5JXiP7MnNFoG4H.png" alt="HTTP调用" style="zoom:67%;" />

<p>​		而<strong>RPC</strong>（<strong>R</strong>emote <strong>P</strong>rocedure <strong>C</strong>all）又叫做<strong>远程过程调用</strong>。它本身并不是一个具体的协议，而是一种<strong>调用方式</strong>。RPC实现了 将远程服务器提供的方法通过 <strong>调用本地方法的方式</strong> 进行调用，以此 <strong>屏蔽掉一些网络细节</strong>。</p>
<img src="https://s2.loli.net/2023/01/13/O9mLMw8jChQz2qY.png" alt="RPC可以像调用本地方法那样调用远端方法" style="zoom:67%;" />

<h3 id="HTTP-x2F-1-1-和-RPC-的区别"><a href="#HTTP-x2F-1-1-和-RPC-的区别" class="headerlink" title="HTTP&#x2F;1.1 和 RPC 的区别"></a>HTTP&#x2F;1.1 和 RPC 的区别</h3><p>​		以下区别，未明确表明的HTTP都 <strong>指代HTTP&#x2F;1.1</strong>。</p>
<h4 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h4><p>​		首先要向某个服务器发起请求，首先需要建立连接，而建立连接的前提是，你得知道<strong>IP地址和端口</strong>。这个找到服务对应的IP端口的过程，其实就是<strong>服务发现</strong>。</p>
<p>​		在<strong>HTTP</strong>中，你知道服务的域名，就可以通过<strong>DNS服务</strong>去解析得到它背后的IP地址，默认80端口。</p>
<p>​		而<strong>RPC</strong>的话，一般会有专门的<strong>中间服务</strong>去保存服务名和IP信息，比如<strong>consul或者etcd，甚至是redis</strong>。想要访问某个服务，就去这些中间服务去获得IP和端口信息。由于dns也是服务发现的一种，所以也有基于dns去做服务发现的组件，比如<strong>CoreDNS</strong>。</p>
<p>​		可以看出服务发现这一块，两者是有些区别，但不太能分高低。</p>
<h4 id="底层连接形式"><a href="#底层连接形式" class="headerlink" title="底层连接形式"></a>底层连接形式</h4><p>​		以主流的<strong>HTTP1.1</strong>协议为例，其默认在建立底层TCP连接之后会一直保持这个连接（<strong>keep alive</strong>），之后的请求和响应都会复用这条连接。</p>
<p>​		而<strong>RPC</strong>协议，也跟HTTP类似，也是通过建立TCP长链接进行数据交互，但不同的地方在于，RPC协议一般还会再建个<strong>连接池</strong>，在请求量大的时候，建立多条连接放在池内，要发数据的时候就从池里取一条连接出来，<strong>用完放回去，下次再复用</strong>，可以说非常环保。</p>
<img src="https://s2.loli.net/2023/01/13/AQCUlvhOYR5in4X.png" alt="connection_pool" style="zoom:67%;" />

<p>​		<strong>由于连接池有利于提升网络请求性能，所以不少编程语言的网络库里都会给HTTP加个连接池</strong></p>
<h4 id="传输的内容"><a href="#传输的内容" class="headerlink" title="传输的内容"></a>传输的内容</h4><p>​		基于TCP传输的消息，说到底，无非都是<strong>消息头header和消息体body。</strong></p>
<p>​		<strong>header</strong>是用于标记一些特殊信息，其中最重要的是<strong>消息体长度</strong>。</p>
<p>​		<strong>body</strong>则是放我们真正需要传输的内容，而这些内容只能是二进制01串，毕竟计算机只认识这玩意。所以TCP传字符串和数字都问题不大，因为字符串可以转成编码再变成01串，而数字本身也能直接转为二进制。但结构体呢，我们得想个办法将它也转为二进制01串，这样的方案现在也有很多现成的，比如<strong>json，protobuf。</strong></p>
<p>​		这个将结构体转为二进制数组的过程就叫<strong>序列化</strong>，反过来将二进制数组复原成结构体的过程叫<strong>反序列化</strong>。</p>
<img src="https://s2.loli.net/2023/01/13/QOBkKlA2i7m8oIr.png" alt="序列化和反序列化" style="zoom:67%;" />

<p>​		对于主流的HTTP1.1，虽然它现在叫<strong>超文本</strong>传输协议，支持音频视频，但HTTP设计初是用于做网页<strong>文本</strong>展示的，所以它传的内容以字符串为主。header和body都是如此。在body这块，它使用<strong>json</strong>来<strong>序列化</strong>结构体数据。</p>
<img src="https://s2.loli.net/2023/01/13/HoQ3SayeC7GW2Y5.png" alt="HTTP报文" style="zoom:50%;" />

<p>​		可以看到这里面的内容非常多的<strong>冗余</strong>，显得<strong>非常啰嗦</strong>。最明显的，像<code>header</code>里的那些信息，其实如果我们约定好头部的第几位是content-type，就<strong>不需要每次都真的把”content-type”这个字段都传过来</strong>，类似的情况其实在<code>body</code>的json结构里也特别明显。</p>
<p>​		而RPC因为它定制化程度更高，可以采用体积更小的protobuf或其他序列化协议去保存结构体数据，同时也不需要像HTTP那样考虑各种浏览器行为，比如302重定向跳转啥的。<strong>因此性能也会更好一些，这也是在公司内部微服务中抛弃HTTP，选择使用RPC的最主要原因。</strong></p>
<img src="https://s2.loli.net/2023/01/13/Fncl8XWiCgtapJ3.png" alt="HTTP原理" style="zoom:67%;" />

<img src="https://s2.loli.net/2023/01/13/oH7QA16YNlFBts8.png" alt="RPC原理" style="zoom:67%;" />

<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><ul>
<li>纯裸TCP是能收发数据，但它是个<strong>无边界</strong>的数据流，上层需要定义<strong>消息格式</strong>用于定义<strong>消息边界</strong>。于是就有了各种协议，HTTP和各类RPC协议就是在TCP之上定义的<strong>应用层</strong>协议。</li>
<li><strong>RPC本质上不算是协议，而是一种调用方式</strong>，而像gRPC和thrift这样的具体实现，才是协议，它们是实现了RPC调用的协议。目的是希望程序员能像调用本地方法那样去调用远端的服务方法。同时RPC有很多种实现方式，<strong>不一定非得基于TCP协议</strong>。</li>
<li>从发展历史来说，<strong>HTTP主要用于b&#x2F;s架构，而RPC更多用于c&#x2F;s架构。但现在其实已经没分那么清了，b&#x2F;s和c&#x2F;s在慢慢融合</strong>。很多软件同时支持多端，所以对外一般用HTTP协议，而内部集群的微服务之间则采用RPC协议进行通讯。</li>
<li>RPC其实比HTTP出现的要早，且比目前主流的HTTP1.1<strong>性能</strong>要更好，所以大部分公司内部都还在使用RPC。</li>
<li><strong>HTTP2.0</strong>在<strong>HTTP1.1</strong>的基础上做了优化，性能可能比很多RPC协议都要好，但由于是这几年才出来的，所以也不太可能取代掉RPC。</li>
</ul>
<h2 id="轮询概念解析"><a href="#轮询概念解析" class="headerlink" title="轮询概念解析"></a>轮询概念解析</h2><p>​		平时我们打开网页，比如购物网站某宝。都是点一下「列表商品」，跳转一下网页就到了「商品详情」。</p>
<p>​		从 HTTP 协议的角度来看，就是点一下网页上的某个按钮，<strong>前端发一次 HTTP请 求，网站返回一次 HTTP 响应</strong>。这种由客户端主动请求，服务器响应的方式也满足大部分网页的功能场景。</p>
<p>​		这种情况下，服务器从来就「不会主动」给客户端发一次消息。就像你喜欢的女生从来不会主动找你一样。</p>
<p>​		但当你点开网页不知名的小广告的时候，你会发现：“大家好，我是渣渣辉！系兄弟就来砍我”，然后远处有个小怪屁颠屁颠地拿着根木棒跑了过来。。。</p>
<p>​		<strong>全程没点任何一次鼠标</strong>。服务器就自动将怪物的移动数据和攻击数据源源不断发给你了。像这种<strong>看起来服务器主动发消息给客户端的场景</strong>，是怎么做到的？</p>
<h3 id="使用-HTTP-不断轮询"><a href="#使用-HTTP-不断轮询" class="headerlink" title="使用 HTTP 不断轮询"></a>使用 HTTP 不断轮询</h3><p>​		其实问题的痛点在于，<strong>怎么样才能在用户不做任何操作的情况下，网页能收到消息并发生变更。</strong></p>
<p>​		最常见的解决方案是，<strong>网页的前端代码里不断定时发 HTTP 请求到服务器，服务器收到请求后给客户端响应消息。</strong>这其实是一种「<strong>伪</strong>」服务器推的形式。它其实并不是服务器主动发消息到客户端，而是客户端自己不断偷偷请求服务器，只是用户无感知而已。</p>
<p>​		用这种方式的场景也有很多，最常见的就是<strong>扫码登录</strong>。比如，某信公众号平台，登录页面二维码出现之后，<strong>前端</strong>网页根本不知道用户扫没扫，于是不断去向<strong>后端</strong>服务器询问，看有没有人扫过这个码。而且是以大概 1 到 2 秒的间隔去不断发出请求，这样可以保证用户在扫码后能在 1 到 2 秒内得到及时的反馈，不至于<strong>等太久</strong>。</p>
<p>​		但这样，会有两个比较明显的问题：</p>
<ul>
<li>当你打开 F12 页面时，你会发现满屏的 HTTP 请求。虽然很小，但这其实也消耗带宽，同时也会增加下游服务器的负担。</li>
<li>最坏情况下，用户在扫码后，需要等个 1~2 秒，正好才触发下一次 HTTP 请求，然后才跳转页面，用户会感到<strong>明显的卡顿</strong>。</li>
</ul>
<p>​		使用起来的体验就是，二维码出现后，手机扫一扫，然后在手机上点个确认，这时候<strong>卡顿等个 1~2 秒</strong>，页面才跳转，甲方爸爸的体验就会非常不好</p>
<h3 id="长轮询"><a href="#长轮询" class="headerlink" title="长轮询"></a>长轮询</h3><p>​		为了低成本解决这个卡顿问题，我们开始了思考：</p>
<p>​		我们知道，HTTP 请求发出后，一般会给服务器留一定的时间做响应，比如 3 秒，规定时间内没返回，就认为是超时。</p>
<p>​		如果我们的 HTTP 请求<strong>将超时设置的很大</strong>，比如 30 秒，<strong>在这 30 秒内只要服务器收到了扫码请求，就立马返回给客户端网页。如果超时，那就立马发起下一次请求。</strong>这样就减少了 HTTP 请求的个数，并且由于大部分情况下，用户都会在某个 30 秒的区间内做扫码操作，所以响应也是及时的。</p>
<img src="https://s2.loli.net/2023/01/13/sLhzOHwaXPyb6BJ.png" alt="图片" style="zoom:67%;" />

<p>​		像这种发起一个请求，在较长时间内等待服务器响应的机制，就是所谓的<strong>长轮询机制</strong>。我们常用的消息队列 RocketMQ 中，消费者去取数据时，也用到了这种方式。</p>
<img src="https://s2.loli.net/2023/01/13/QPftHWohAlI14wG.png" alt="图片" style="zoom:67%;" />

<p>​		像这种，在用户不感知的情况下，服务器将数据推送给浏览器的技术，就是所谓的<strong>服务器推送</strong>技术，它还有个毫不沾边的英文名，<strong>comet</strong> 技术，大家听过就好。</p>
<p>​		上面提到的两种解决方案（不断轮询和长轮询），本质上，其实还是客户端主动去取数据。对于像扫码登录这样的<strong>简单场景</strong>还能用用。但如果是网页游戏呢，游戏一般会有大量的数据需要从服务器主动推送到客户端。这就得说下 <strong>WebSocket</strong> 了。</p>
<h2 id="WebSocket协议"><a href="#WebSocket协议" class="headerlink" title="WebSocket协议"></a>WebSocket协议</h2><p>​		我们知道 TCP 连接的两端，<strong>同一时间里</strong>，<strong>双方</strong>都可以<strong>主动</strong>向对方发送数据。这就是所谓的<strong>全双工</strong>。</p>
<p>​		而现在使用最广泛的<code>HTTP/1.1</code>，也是基于TCP协议的，<strong>同一时间里</strong>，客户端和服务器<strong>只能有一方主动</strong>发数据，这就是所谓的<strong>半双工</strong>。</p>
<p>​		由于 HTTP 协议设计之初，考虑的是看看网页文本的场景，能做到<strong>客户端发起请求再由服务器响应</strong>就够了，根本就没考虑网页游戏这种 <strong>客户端和服务器之间都要互相主动发大量数据</strong> 的场景。导致好好的全双工 TCP，被 HTTP&#x2F;1.1 用成了半双工。</p>
<p>​		为了更好的支持类似网页游戏这样的场景，我们需要另外一个<strong>基于TCP的新协议——WebSocket</strong>。</p>
<h3 id="建立WebSocket连接"><a href="#建立WebSocket连接" class="headerlink" title="建立WebSocket连接"></a>建立WebSocket连接</h3><p>​		我们平时刷网页，一般都是在浏览器上刷的，刷图文的时候用的是 <strong>HTTP 协议</strong>，一打开网页游戏，这时候就得切换成我们新介绍的 <strong>WebSocket 协议</strong>。</p>
<p>​		为了兼容这些使用场景。浏览器在 <strong>TCP 三次握手</strong>建立连接之后，都<strong>统一使用 HTTP 协议</strong>先进行一次通信。</p>
<ul>
<li>如果此时是<strong>普通的 HTTP 请求</strong>，那后续双方就还是老样子继续用普通 HTTP 协议进行交互，这点没啥疑问。</li>
<li>如果这时候是<strong>想建立 WebSocket 连接</strong>，就会在 HTTP 请求里带上一些<strong>特殊的header 头</strong>，如下：</li>
</ul>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>Upgrade</span><br><span class="line"><span class="attribute">Upgrade</span><span class="punctuation">: </span>WebSocket</span><br><span class="line"><span class="attribute">Sec-WebSocket-Key</span><span class="punctuation">: </span>T2a6wZlAwhgQNqruZ2YUyg==\r\n</span><br></pre></td></tr></table></figure>

<p>​		这些 header 头的意思是，浏览器想<strong>升级协议（Connection: Upgrade）</strong>，并且<strong>想升级成 WebSocket 协议（Upgrade: WebSocket）</strong>。同时带上一段<strong>随机生成的 base64 码（Sec-WebSocket-Key）</strong>，发给服务器。</p>
<p>​		如果服务器正好支持升级成 WebSocket 协议。就会走 WebSocket 握手流程，同时根据客户端生成的 base64 码，用某个<strong>公开的</strong>算法变成另一段字符串，放在 HTTP 响应的 <code>Sec-WebSocket-Accept</code> 头里，同时带上<code>101状态码</code>，发回给浏览器。HTTP 的响应如下：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">101</span> Switching Protocols\r\n</span><br><span class="line"><span class="attribute">Sec-WebSocket-Accept</span><span class="punctuation">: </span>iBJKv/ALIW2DobfoA4dmr3JHBCY=\r\n</span><br><span class="line"><span class="attribute">Upgrade</span><span class="punctuation">: </span>WebSocket\r\n</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>Upgrade\r\n</span><br></pre></td></tr></table></figure>

<p>​		101 挺不常见，它其实是指<strong>协议切换</strong>。</p>
<img src="https://s2.loli.net/2023/01/13/Y4WpogdKDIsjM7f.png" alt="图片" style="zoom:67%;" />

<p>​		之后，浏览器也用同样的<strong>公开算法</strong>将<code>base64码</code>转成另一段字符串，如果这段字符串跟服务器传回来的<strong>字符串一致</strong>，那验证通过。</p>
<img src="https://s2.loli.net/2023/01/13/kPOaKrM8xmN9jUS.png" alt="图片" style="zoom:67%;" />

<p>​		就这样经历了一来一回两次 HTTP 握手，WebSocket就建立完成了，后续双方就可以使用 webscoket 的数据格式进行通信了。</p>
<img src="https://s2.loli.net/2023/01/13/aLt72YDNvP9WTsH.png" alt="图片" style="zoom:67%;" />

<blockquote>
<p>“WebSocket 是基于HTTP的新协议” 这句话对吗？</p>
</blockquote>
<p>​		不对！！！WebSocket只有在建立连接时才用到了HTTP，<strong>升级完成之后就跟HTTP没有任何关系了</strong>。</p>
<p>​		这就好像你喜欢的女生通过你要到了你大学室友的微信，然后他们自己就聊起来了。你能说这个女生是通过你去跟你室友沟通的吗？不能。你跟HTTP一样，都只是个<strong>工具人</strong>。</p>
<h3 id="WebSocket的消息格式"><a href="#WebSocket的消息格式" class="headerlink" title="WebSocket的消息格式"></a>WebSocket的消息格式</h3><p>​		上面提到在完成协议升级之后，两端就会用webscoket的数据格式进行通信。数据包在WebSocket中被叫做<strong>帧</strong>。</p>
<img src="https://s2.loli.net/2023/01/13/O9rBXq4C5HZSjoh.png" alt="图片" style="zoom:67%;" />

<p>​		这里面字段很多，但我们只需要关注下面这几个。</p>
<p><strong>opcode字段</strong>：这个是用来标志这是个<strong>什么类型</strong>的数据帧。比如：</p>
<ul>
<li>等于 1 ，是指text类型（<code>string</code>）的数据包</li>
<li>等于 2 ，是二进制数据类型（<code>[]byte</code>）的数据包</li>
<li>等于 8 ，是关闭连接的信号</li>
</ul>
<p><strong>payload字段</strong>：存放的是我们<strong>真正想要传输的数据的长度</strong>，单位是<strong>字节</strong>。比如你要发送的数据是<code>字符串&quot;111&quot;</code>，那它的长度就是<code>3</code>。</p>
<img src="https://s2.loli.net/2023/01/13/8F9ZXHzj6QdrcuE.png" alt="图片" style="zoom:67%;" />

<p>​		另外，我们存放<strong>payload 长度的字段有好几个</strong>，我们既可以用最前面的<code>7bit</code>, 也可以用后面的<code>7+16bit 或 7+64bit。</code></p>
<blockquote>
<p>怎么知道<strong>什么情况下应该读 7 bit，什么情况下应该读7+16bit呢？</strong></p>
</blockquote>
<p>​		WebSocket会用最开始的7bit做标志位。不管接下来的数据有多大，都<strong>先读最先的7个bit</strong>，根据它的取值决定还要不要再读个 16bit 或 64bit。</p>
<ul>
<li>如果 <strong>最开始的7bit</strong> 的值是 0~125，那么它就表示了 <strong>payload 全部长度</strong>，只读最开始的<code>7个bit</code>就完事了。</li>
</ul>
<img src="https://s2.loli.net/2023/01/13/1TCjfeZkwoRdh72.png" alt="图片" style="zoom:67%;" />

<ul>
<li>如果是<code>126（0x7E）</code>。那它表示payload的长度范围在 <code>126~65535</code> 之间，接下来还需要<strong>再读16bit</strong>。这16bit会包含payload的真实长度。</li>
</ul>
<img src="https://s2.loli.net/2023/01/13/sSIfbmLhpU1zqwG.png" alt="图片" style="zoom:67%;" />

<ul>
<li>如果是<code>127（0x7F）</code>。那它表示payload的长度范围<code>&gt;=65536</code>，接下来还需要<strong>再读64bit</strong>。这64bit会包含payload的长度。这能放2的64次方byte的数据，换算一下好多个TB，肯定够用了。</li>
</ul>
<img src="https://s2.loli.net/2023/01/13/c5JoU9Qg2VES4rk.png" alt="图片" style="zoom:67%;" />

<p><strong>payload data字段</strong>：这里存放的就是真正要传输的数据，在知道了上面的payload长度后，就可以根据这个值去截取对应的数据。</p>
<p>​		WebSocket的数据格式也是<strong>数据头（内含payload长度） + payload data</strong> 的形式。这是因为 TCP 协议本身就是全双工，但直接使用<strong>纯裸TCP</strong>去传输数据，会有<strong>粘包</strong>的”问题”。为了解决这个问题，上层协议一般会用<strong>消息头+消息体</strong>的格式去重新包装要发的数据。而<strong>消息头</strong>里一般含有<strong>消息体的长度</strong>，通过这个长度可以去截取真正的消息体。</p>
<h3 id="WebSocket的使用场景"><a href="#WebSocket的使用场景" class="headerlink" title="WebSocket的使用场景"></a>WebSocket的使用场景</h3><p>​		WebSocket完美继承了 TCP 协议的<strong>全双工</strong>能力，并且还贴心的提供了解决粘包的方案。它适用于<strong>需要服务器和客户端（浏览器）频繁交互</strong>的大部分场景，比如网页&#x2F;小程序游戏，网页聊天室，以及一些类似飞书这样的网页协同办公软件。</p>
<p>​		回到文章开头的问题，在使用 WebSocket 协议的网页游戏里，怪物移动以及攻击玩家的行为是<strong>服务器逻辑</strong>产生的，对玩家产生的伤害等数据，都需要由<strong>服务器主动发送给客户端</strong>，客户端获得数据后展示对应的效果。</p>
<h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><ul>
<li>TCP 协议本身是<strong>全双工</strong>的，但我们最常用的 HTTP&#x2F;1.1，虽然是基于 TCP 的协议，但它是<strong>半双工</strong>的，对于大部分需要服务器主动推送数据到客户端的场景，都不太友好，因此我们需要使用支持全双工的 WebSocket 协议。</li>
<li>在 HTTP&#x2F;1.1 里，只要客户端不问，服务端就不答。基于这样的特点，对于登录页面这样的简单场景，可以使用<strong>定时轮询或者长轮询</strong>的方式实现<strong>服务器推送</strong>(comet)的效果。</li>
<li>对于客户端和服务端之间需要频繁交互的复杂场景，比如网页游戏，都可以考虑使用 WebSocket 协议。</li>
<li>WebSocket 和 socket 几乎没有任何关系，只是叫法相似。</li>
<li>正因为各个浏览器都支持 HTTP协 议，所以 WebSocket 会先利用HTTP协议加上一些特殊的 header 头进行握手升级操作，升级成功后就跟 HTTP 没有任何关系了，之后就用 WebSocket 的数据格式进行收发数据。</li>
</ul>
<h1 id="应用层-SSL-x2F-TSL"><a href="#应用层-SSL-x2F-TSL" class="headerlink" title="应用层-SSL&#x2F;TSL"></a>应用层-SSL&#x2F;TSL</h1><p>​		SSL 即安全套接层（Secure Sockets Layer），在 OSI 七层模型中处于**会话层(第 5 层)**。</p>
<p>​		SSL 出过三个大版本，当它发展到 <strong>第三个大版本</strong> 的时候才被标准化，成为 TLS（传输层安全，Transport Layer Security）</p>
<p>​		现在主流的版本是 TLS&#x2F;1.2，在 2018 年推出了更加优秀的 TLS1.3，大大优化了 TLS 握手过程。</p>
<h2 id="对称加密算法"><a href="#对称加密算法" class="headerlink" title="对称加密算法"></a>对称加密算法</h2><p>​		对称加密算法的原理很简单：加密&#x2F;解密双方只要拥有同一秘钥即可完成加密&#x2F;解密的过程</p>
<p>​		但对称加密算法容易引出一个问题： <strong>秘钥如何安全传输？</strong></p>
<p>​		因为需求带动了生产，出现了 <strong>非对称加密算法</strong></p>
<h2 id="非对称加密算法"><a href="#非对称加密算法" class="headerlink" title="非对称加密算法"></a>非对称加密算法</h2><p>​		一般而言，非对称加密算法都指的是 <strong>RSA</strong>。RSA算法基于一个简单的数理理论：</p>
<blockquote>
<p>将两个大素数相乘十分容易，但是想要对其乘积进行因式分解却极其困难，因此可以将乘积公开作为加密密钥</p>
</blockquote>
<p>​		通过RSA算法可以得出规则：<strong>通讯的双方各有一套公钥和私钥，同一套公钥和私钥中公钥的加密需要私钥才能解密，私钥的加密需要公钥才能解密。</strong></p>
<p>​		举个例子，A把自己的公钥公开，B拿到了A的公钥，然后用A的公钥加密数据包发送回给A，A再用自己的私钥解密就得到了明文。在这个过程中任何第三方拦截了信息都没法破解，有了这个算法之后安全性就有了保障。</p>
<h2 id="对称和非对称的区别"><a href="#对称和非对称的区别" class="headerlink" title="对称和非对称的区别"></a>对称和非对称的区别</h2><ol>
<li>对称加密中加密和解密使用的秘钥是同一个；非对称加密中采用两个密钥，一般使用公钥进行加密，私钥进行解密。</li>
<li>对称加密解密的速度比较快，非对称加密和解密花费的时间长、速度相对较慢。</li>
<li>对称加密的安全性相对较低，非对称加密的安全性较高。</li>
</ol>
<p>​		非对称加密算法相比对称加密算法，安全性得到了巨大提高。</p>
<blockquote>
<p>可非对称加密算法就 <strong>绝对安全</strong> 了吗？答案是否定的。</p>
</blockquote>
<h2 id="中间人攻击"><a href="#中间人攻击" class="headerlink" title="中间人攻击"></a>中间人攻击</h2><p>​		在非对称加密算法中，双方的公钥都是公开的，并没有任何证据可以<strong>证明公钥属于A还是B</strong>，如果这个时候有个中间人M，通过某种途径加入了双方的通信中，就很有可能窃取到双方信息。</p>
<img src="https://s2.loli.net/2023/01/10/uAfSN8xpE3vzayq.png" alt="img" style="zoom: 80%;" />

<p>​		在A向B通信的时候，A要拿到B的公钥加密信息，这个时候中间人M谎称自己的公钥是B的公钥，于是A拿M的公钥加密了信息传递出去，这时候M拿到了信息并用自己的私钥解密信息，随后再用B的公钥加密发送给了B。</p>
<p>​		在这个过程中A和B以为通信绝对安全，但实际上早就被M拿到了信息明文。至于M是如何中间人的，实际上是另外一个安全问题了。这里的关键是只要M让A相信公钥是B的，就可以做中间人攻击。</p>
<img src="https://s2.loli.net/2023/01/10/GwhoDBMuzy1L5Zq.webp" alt="img" style="zoom:80%;" />

<h2 id="CA-–-第三方认证机构"><a href="#CA-–-第三方认证机构" class="headerlink" title="CA – 第三方认证机构"></a>CA – 第三方认证机构</h2><p>​		为了解决中间人攻击这个问题，需要解决一个问题——<strong>证明公钥的拥有者</strong>，为了使证明具有信服力，我们需要一个专门吃这口饭的第三方认证机构来实现。第三方认证机构要做的事情简单来讲就一个，确保A拿到的公钥真正属于B，而非其它浑水摸鱼的中间人M。</p>
<p>​		那么认证机构是如何使认证结果具有信服力的呢？</p>
<ul>
<li><strong>机构可信任度</strong></li>
</ul>
<p>​		在互联网中，最具有公信力的最顶级的认证就是 <strong>CA认证</strong> 了，只要是这个CA颁发的证书就是可信任的，通常作为<strong>根证书</strong>。</p>
<p>​		依托根证书的可信任度，其它中间机构向顶级CA申请了中间CA证书，就这样一层层下来，最终个人CA向上级某一CA申请的证书就是最终的<strong>终端普通数字证书</strong>，整个签发关系就叫<strong>证书链</strong></p>
<ul>
<li><p><strong>证书的防伪性</strong></p>
<p>在日常生活中，我们有防伪商标、防伪码等形式确保正品，在互联网中，我们通过 <strong>数字签名</strong> 实现向第三方机构查询验证相关信息正确的过程。</p>
</li>
</ul>
<p>​		数字签名是CA用自己的私钥对B的个人信息进行非对称加密所得到的，当A得到B提供的数字证书，B也同时得到了A的个人信息和数字签名，然后用CA提供的公钥对数字签名进行解密，再拿其和A的个人信息进行比对，如果一样则证明该数字证书是CA认证过的。</p>
<ul>
<li><strong>摘要算法</strong></li>
</ul>
<p>​		我们都知道，非对称加密算法 <strong>生成数字签名以及解密数字签名</strong> 的耗时比较长，如果再加上校验，那对于访问效率而言是不利的。摘要算法的作用顾名思义就是取出原文中精简过的部分，它可将任意大小的原文信息加密并摘要成<strong>固定长度的简短密文</strong>，意思就是对于不同的原文信息，采用同一摘要算法可以得到同一长度的密文。依靠此算法就可以解决个人信息过大导致的时间过长问题。</p>
<h2 id="TSL-1-2-握手过程"><a href="#TSL-1-2-握手过程" class="headerlink" title="TSL 1.2 握手过程"></a>TSL 1.2 握手过程</h2> <img src="https://s2.loli.net/2023/01/12/ypGsLfE3U2tYgSB.png" alt="img" style="zoom: 67%;" />

<p>​		上图简要概述了 TLS 的握手过程，其中每一个「框」都是一个记录（<em>record</em>），记录是 TLS 收发数据的基本单位，类似于 TCP 里的 segment。多个记录可以组合成一个 TCP 包发送，所以<strong>通常经过「四个消息」就可以完成 TLS 握手，也就是需要 2个 RTT 的时延</strong>，然后就可以在安全的通信环境里发送 HTTP 报文，实现 HTTPS 协议。</p>
<p>​		所以可以发现，HTTPS 是<strong>应用层</strong>协议，需要先完成 TCP 连接建立，然后走 TLS 握手过程后，才能建立通信安全的连接。</p>
<h3 id="RSA-握手解析"><a href="#RSA-握手解析" class="headerlink" title="RSA 握手解析"></a>RSA 握手解析</h3><p>​		传统的 TLS 握手基本都是使用 RSA 算法来实现密钥交换的，在将 TLS 证书部署服务端时，<strong>证书文件其实就是服务端的公钥</strong>，会在 TLS 握手阶段传递给客户端，而服务端的私钥则一直留在服务端，一定要确保私钥不能被窃取。</p>
<p>​		在 RSA 密钥协商算法中，客户端会生成随机密钥，并使用服务端的公钥加密后再传给服务端。根据<em>非对称加密算法</em>，公钥加密的消息仅能通过私钥解密，这样服务端解密后，双方就得到了相同的密钥，再用它加密应用消息。</p>
<p>​		用 Wireshark 工具抓了用 RSA 密钥交换的 TLS 握手过程，可以看到共经历了四次握手：</p>
<img src="https://s2.loli.net/2023/01/12/wazWOJeuUiTN2QP.png" alt="img" style="zoom:67%;" />

<p>​		同时，从下图可以很清晰地看到用 RSA 密钥交换的 TLS 握手全过程：</p>
<img src="https://s2.loli.net/2023/01/12/f7yFZH4GcoxkQsi.png" alt="img" style="zoom: 50%;" />

<h3 id="RSA握手过程"><a href="#RSA握手过程" class="headerlink" title="RSA握手过程"></a>RSA握手过程</h3><h4 id="TLS-第一次握手"><a href="#TLS-第一次握手" class="headerlink" title="TLS 第一次握手"></a>TLS 第一次握手</h4><p>​		客户端首先会发一个「<strong>Client Hello</strong>」消息，跟服务器「打招呼」。</p>
<img src="https://s2.loli.net/2023/01/12/gawfbXF5lZyTJ6o.png" alt="img" style="zoom: 80%;" />

<p>​		消息里面有客户端使用的 TLS 版本号、支持的密码套件列表，以及生成的  <strong>随机数（Client Random）</strong>，这个随机数会被服务端保留，它是生成对称加密密钥的材料之一。</p>
<h4 id="TLS-第二次握手"><a href="#TLS-第二次握手" class="headerlink" title="TLS 第二次握手"></a>TLS 第二次握手</h4><p>​		当服务端收到客户端的「Client Hello」消息后，会确认 TLS 版本号是否支持，和从密码套件列表中选择一个密码套件，以及生成 <strong>随机数（Server Random）</strong>。接着，返回「<strong>Server Hello</strong>」消息，消息里面有服务器确认的 TLS 版本号，也给出了随机数（Server Random），然后从客户端的密码套件列表选择了一个合适的<strong>密码套件</strong>。</p>
<img src="https://s2.loli.net/2023/01/12/JBczpgy4weH6v7Y.png" alt="img" style="zoom:80%;" />

<p>​		密码套件是有固定格式和规范的。基本的形式是「<strong>密钥交换算法 + 签名算法 + 对称加密算法 + 摘要算法</strong>」， 一般 WITH 单词前面有两个单词，第一个单词是约定密钥交换的算法，第二个单词是约定证书的验证算法。比如上图的密码套件的意思就是：</p>
<ul>
<li>由于 WITH 单词只有一个 RSA，则说明握手时密钥交换算法和签名算法都是使用 RSA；</li>
<li>握手后的通信使用 AES 对称算法，密钥长度 128 位，分组模式是 GCM；</li>
<li>摘要算法 SHA256 用于消息认证和产生随机数；</li>
</ul>
<p>​		通过前面这两个客户端和服务端相互「打招呼」的过程，客户端和服务端就已确认了 TLS 版本和使用的密码套件，而且客户端和服务端都会各自生成一个随机数，并且还会把随机数传递给对方。这两个随机数在后续会作为<strong>生成「会话密钥」的条件</strong>，所谓的会话密钥就是数据传输时，所使用的对称加密密钥。</p>
<p>​		然后，服务端为了证明自己的身份，会发送「<strong>Server Certificate</strong>」给客户端，这个消息里含有数字证书。</p>
<img src="https://s2.loli.net/2023/01/12/VAXER231pSJc6Pq.png" alt="img" style="zoom:80%;" />

<p>​		随后，服务端发了「<strong>Server Hello Done</strong>」消息，目的是告诉客户端，我已经把该给你的东西都给你了，本次打招呼完毕。</p>
<img src="https://s2.loli.net/2023/01/12/jWgL5KTBmcNSYE9.png" alt="img"  />

<h4 id="TLS-第三次握手"><a href="#TLS-第三次握手" class="headerlink" title="TLS 第三次握手"></a>TLS 第三次握手</h4><p>​		客户端验证完证书后，认为可信则客户端就会生成一个新的<strong>随机数 (*pre-master*)<strong>，用服务器的 RSA 公钥加密该随机数，通过「</strong>Client Key Exchange</strong>」消息传给服务端。</p>
<img src="https://s2.loli.net/2023/01/12/VDtPC9ELbelchMs.png" alt="img" style="zoom:80%;" />

<p>​		服务端收到后，用 RSA 私钥解密，得到客户端发来的随机数 (pre-master)。至此，客户端和服务端双方都共享了三个随机数，分别是<strong>Client Random、Server Random、pre-master</strong>。</p>
<p>​		于是，双方根据已经得到的三个随机数，生成<strong>会话密钥（Master Secret）</strong>，它是对称密钥，用于对后续的 HTTP 请求&#x2F;响应的数据加解密。生成完「会话密钥」后，然后客户端发一个「<strong>Change Cipher Spec</strong>」，告诉服务端开始使用加密方式发送消息。</p>
<p><img src="https://s2.loli.net/2023/01/12/gnz39hTb5DqOx7L.png" alt="img"></p>
<p>​		然后，客户端再发一个「<strong>Encrypted Handshake Message（Finishd）</strong>」消息，把之前所有发送的数据做个<strong>摘要</strong>，再用会话密钥（master secret）加密一下，让服务器做个验证，验证加密通信「是否可用」和「之前握手信息是否有被中途篡改过」。</p>
<p><img src="https://s2.loli.net/2023/01/12/sfyINZFRwpUz45l.png" alt="img"></p>
<blockquote>
<p><strong>注意</strong> ： 「Change Cipher Spec」之前传输的 TLS 握手数据都是明文，之后都是对称密钥加密的密文。</p>
</blockquote>
<h4 id="TLS-第四次握手"><a href="#TLS-第四次握手" class="headerlink" title="TLS 第四次握手"></a>TLS 第四次握手</h4><p>​		服务器也是同样的操作，发「<strong>Change Cipher Spec</strong>」和「<strong>Encrypted Handshake Message</strong>」消息，如果双方都验证加密和解密没问题，那么握手正式完成。最后就可以用「会话密钥」加解密 HTTP 请求和响应。</p>
<h3 id="RSA-算法的缺陷"><a href="#RSA-算法的缺陷" class="headerlink" title="RSA 算法的缺陷"></a>RSA 算法的缺陷</h3><p>​		<strong>使用 RSA 密钥协商算法的最大问题是不支持前向保密</strong>。</p>
<p>​		因为客户端传递随机数（用于生成对称加密密钥的条件之一）给服务端时使用的是公钥加密的，服务端收到后，会用私钥解密得到随机数。所以一旦服务端的私钥泄漏了，过去被第三方截获的所有 TLS 通讯密文都会被破解。</p>
<p>​		为了解决这个问题，就出现了我们现在大多数网站使用的 ECDHE 密钥协商算法。</p>
<h3 id="ECDHE-握手解析"><a href="#ECDHE-握手解析" class="headerlink" title="ECDHE 握手解析"></a>ECDHE 握手解析</h3><h4 id="离散对数"><a href="#离散对数" class="headerlink" title="离散对数"></a>离散对数</h4><p>​		ECDHE 密钥协商算法是 <strong>DH 算法</strong>演进过来的，所以我们先从 DH 算法说起。</p>
<p>​		DH 算法是<strong>非对称加密算法</strong>， 因此它可以用于密钥交换，该算法的核心数学思想是<strong>离散对数</strong>。离散对数是「离散 + 对数」的两个数学概念的组合，要说起对数，必然要说指数，因为它们是互为反函数，<strong>指数就是幂运算，对数是指数的逆运算</strong>。</p>
<img src="https://s2.loli.net/2023/01/12/sXMeT4lQIaHhBAq.png" alt="img" style="zoom:80%;" />

<p>​		举个例子，对于底数为 2 的时候， 32 的对数是 5，64 的对数是 6</p>
<img src="https://s2.loli.net/2023/01/12/Dc9WsbiMdGlqx28.png" alt="img" style="zoom:80%;" />

<p>​		离散对数是在对数运算的基础上加了「模运算」，也就说<strong>取余数</strong>。当<strong>模数 p 是一个很大的质数</strong>，即使知道底数 a 和真数 b ，在现有的计算机的计算水平是几乎<strong>无法算出离散对数</strong>的，这就是 DH 算法的数学基础。</p>
<img src="https://s2.loli.net/2023/01/12/EWNphs5f1eGgbcD.png" alt="img" style="zoom:80%;" />

<h4 id="DH-算法"><a href="#DH-算法" class="headerlink" title="DH 算法"></a>DH 算法</h4><p>​		认识了离散对数，我们来看看 DH 算法是如何密钥交换的：现假设小红和小明约定使用 DH 算法来交换密钥，那么基于离散对数，小红和小明需要先确定模数和底数作为算法的参数，这两个参数是公开的，用 <strong>P 和 G</strong> 来代称。</p>
<p>​		然后小红和小明各自生成一个随机整数作为<strong>私钥</strong>，双方的私钥要各自严格保管，不能泄漏，小红的私钥用 <code>a</code> 代称，小明的私钥用 <code>b</code> 代称。</p>
<p>​		现在小红和小明双方都有了 P 和 G 以及各自的私钥，于是就可以计算出<strong>公钥</strong>：</p>
<ul>
<li>小红的公钥记作 A，<code>A = G ^ a ( % P )</code>；</li>
<li>小明的公钥记作 B，<code>B = G ^ b ( % P )</code>；</li>
</ul>
<p>​		A 和 B 也是公开的，因为根据离散对数的原理，从真数（A 和 B）反向计算对数 a 和 b 是非常困难的，至少在现有计算机的计算能力是无法破解的，如果量子计算机出来了，那就有可能被破解，当然如果量子计算机真的出来了，那么密钥协商算法就要做大的升级了。</p>
<p>​		双方交换各自 DH 公钥后，小红手上共有 5 个数：P、G、<strong>a</strong>、A、B，小明手上也同样共有 5 个数：P、G、<strong>b</strong>、B、A。</p>
<p>​		然后小红执行运算： <code>B ^ a ( mod P )</code>，其结果为 <code>K</code>，因为离散对数的幂运算有交换律，所以小明执行运算： <code>A ^ b ( mod P )</code>，得到的结果也是 <code>K</code>。</p>
<img src="https://s2.loli.net/2023/01/12/V9uGyUJSkReY3Qs.png" alt="img" style="zoom: 67%;" />

<p>​		这个 <code>K</code> 就是小红和小明之间用的<strong>对称加密密钥</strong>，可以作为会话密钥使用。</p>
<p>​		可以看到，整个密钥协商过程中，小红和小明公开了 4 个信息：P、G、A、B，其中 <strong>P、G 是算法的参数</strong>，<strong>A 和 B 是公钥</strong>，而 a、b 是双方各自保管的私钥，黑客无法获取这 2 个私钥，因此黑客只能从公开的 P、G、A、B 入手，计算出离散对数（私钥）。</p>
<p>​		根据离散对数的原理，如果 P 是一个大数，现有的计算机的算力是很难破解出 私钥 a、b 的，破解不出私钥也就无法计算出会话密钥，因此 <strong>DH 密钥交换是安全的</strong>。</p>
<h4 id="DHE-算法"><a href="#DHE-算法" class="headerlink" title="DHE 算法"></a>DHE 算法</h4><p>​		根据私钥生成的方式，DH 算法分为两种实现：</p>
<ul>
<li>static DH 算法，这个是已经被废弃了；</li>
<li>DHE 算法，现在常用的；</li>
</ul>
<p>​		static DH 算法里有一方的私钥是静态的，也就说每次密钥协商的时候有一方的私钥都是一样的，一般是服务器方固定，即 a 不变，客户端的私钥则是随机生成的。于是，DH 交换密钥时就只有客户端的公钥是变化，而服务端公钥是不变的，那么随着时间延长，黑客就会截获海量的密钥协商过程的数据，因为密钥协商的过程有些数据是公开的，黑客就可以依据这些数据暴力破解出服务器的私钥，然后就可以计算出会话密钥了，于是之前截获的加密数据会被破解，所以 <strong>static DH 算法不具备前向安全性</strong>。</p>
<p>​		既然固定一方的私钥有被破解的风险，那么干脆就让双方的私钥在每次密钥交换通信时，都是随机生成的、临时的，这个方式也就是 DHE 算法，<strong>E 全称是 ephemeral（临时性的）</strong>。</p>
<p>​		所以，即使有个牛逼的黑客破解了某一次通信过程的私钥，其他通信过程的私钥仍然是安全的，因为<strong>每个通信过程的私钥都是没有任何关系的，都是独立的，这样就保证了「前向安全」</strong>。</p>
<h4 id="ECDHE-算法"><a href="#ECDHE-算法" class="headerlink" title="ECDHE 算法"></a>ECDHE 算法</h4><p>​		DHE 算法由于计算性能不佳，因为需要做大量的乘法，为了提升 DHE 算法的性能，所以就出现了现在广泛用于密钥交换算法 —— <strong>ECDHE 算法</strong>。</p>
<p>​		ECDHE 算法是在 DHE 算法的基础上利用了 ECC 椭圆曲线特性，可以用更少的计算量计算出公钥，以及最终的会话密钥。</p>
<p>​		小红和小明使用 ECDHE 密钥交换算法的过程：</p>
<ul>
<li>双方事先确定好使用哪种椭圆曲线，和曲线上的基点 G，这两个参数都是公开的；</li>
<li>双方各自随机生成一个随机数作为<strong>私钥d</strong>，并与基点 G相乘得到<strong>公钥Q</strong>（Q &#x3D; dG），此时小红的公私钥为 Q1 和 d1，小明的公私钥为 Q2 和 d2；</li>
<li>双方交换各自的公钥，最后小红计算点（x1，y1） &#x3D; d1Q2，小明计算点（x2，y2） &#x3D; d2Q1，由于椭圆曲线上是可以满足乘法交换和结合律，所以 d1Q2 &#x3D; d1d2G &#x3D; d2d1G &#x3D; d2Q1 ，因此<strong>双方的 x 坐标是一样的，所以它是共享密钥，也就是会话密钥</strong>。</li>
</ul>
<p>​		这个过程中，双方的私钥都是随机、临时生成的，都是不公开的，即使根据公开的信息（椭圆曲线、公钥、基点 G）也是很难计算出椭圆曲线上的离散对数（私钥）。</p>
<h3 id="ECDHE-握手过程"><a href="#ECDHE-握手过程" class="headerlink" title="ECDHE 握手过程"></a>ECDHE 握手过程</h3><p>​		用 Wireshark 工具抓了用 ECDHE 密钥协商算法的 TSL 握手过程，可以看到是四次握手：</p>
<img src="https://s2.loli.net/2023/01/12/nCtDyLKAi4mgEXv.png" alt="img" style="zoom: 67%;" />

<p>​		<strong>使用了 ECDHE，在 TLS 第四次握手前，客户端就已经发送了加密的 HTTP 数据</strong>，而对于 RSA 握手过程，必须要完成 TLS 四次握手，才能传输应用数据。所以，<strong>ECDHE 相比 RSA 握手过程省去了一个消息往返的时间</strong>，这个有点「抢跑」的意思，它被称为是「<em>TLS False Start</em>」，跟「<em>TCP Fast Open</em>」有点像，都是在还没连接完全建立前，就发送了应用数据，这样便提高了传输的效率。</p>
<h4 id="TLS-第一次握手-1"><a href="#TLS-第一次握手-1" class="headerlink" title="TLS 第一次握手"></a>TLS 第一次握手</h4><p>​		客户端首先会发一个「<strong>Client Hello</strong>」消息，消息里面有客户端使用的 TLS 版本号、支持的密码套件列表，以及生成的<strong>随机数（*Client Random*）</strong>。</p>
<img src="https://s2.loli.net/2023/01/12/lk13LiUvEzOPdR5.png" alt="img" style="zoom:80%;" />

<h4 id="TLS-第二次握手-1"><a href="#TLS-第二次握手-1" class="headerlink" title="TLS 第二次握手"></a>TLS 第二次握手</h4><p>​		服务端收到客户端的「打招呼」，同样也要回礼，会返回「<strong>Server Hello</strong>」消息，消息面有服务器确认的 TLS 版本号，也给出了一个<strong>随机数（Server Random）</strong>，然后从客户端的密码套件列表选择了一个合适的密码套件。</p>
<img src="https://s2.loli.net/2023/01/12/HutnX1jqa34ZrVT.png" alt="img" style="zoom: 80%;" />

<p>​		不过这次选择的密码套件就和 RSA 不一样了，我们来分析一下这次的密码套件的意思：「 TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384」</p>
<ul>
<li>密钥协商算法使用 ECDHE；</li>
<li>签名算法使用 RSA；</li>
<li>握手后的通信使用 AES 对称算法，密钥长度 256 位，分组模式是 GCM；</li>
<li>摘要算法使用 SHA384；</li>
</ul>
<p>​		接着，服务端为了证明自己的身份，发送「<strong>Certificate</strong>」消息，会把证书也发给客户端。</p>
<img src="https://s2.loli.net/2023/01/12/YZ21WpMX3eq9azc.png" alt="img" style="zoom: 80%;" />

<p>​		<strong>注意：</strong>这一步就和 RSA 握手过程有很大的区别了，因为服务端选择了 ECDHE 密钥协商算法，所以会在发送完证书后，发送「<strong>Server Key Exchange</strong>」消息。这个过程服务器做了三件事：</p>
<ul>
<li>选择了<strong>名为 x25519 的椭圆曲线</strong>，选好了椭圆曲线相当于椭圆曲线基点 G 也定好了，这些都会公开给客户端；</li>
<li>生成随机数作为服务端椭圆曲线的私钥，保留到本地；</li>
<li>根据基点 G 和私钥计算出<strong>服务端的椭圆曲线公钥</strong>，这个会公开给客户端。</li>
</ul>
<p>​		为了保证这个椭圆曲线的公钥不被第三方篡改，服务端会用 RSA 签名算法给服务端的椭圆曲线公钥做个签名。</p>
<img src="https://s2.loli.net/2023/01/12/8HUDcBguvOpXWtj.png" alt="img" style="zoom:80%;" />

<p>​		随后，就是「<strong>Server Hello Done</strong>」消息，服务端跟客户端表明：“这些就是我提供的信息，打招呼完毕”。</p>
<p><img src="https://s2.loli.net/2023/01/12/TIhsDwtcQFqPvdl.png" alt="img"></p>
<p>​		至此，TLS 两次握手就已经完成了，目前客户端和服务端通过<strong>明文共享</strong>了这几个信息：<strong>Client Random、Server Random 、使用的椭圆曲线、椭圆曲线基点 G、服务端椭圆曲线的公钥</strong>，这几个信息很重要，是后续生成会话密钥的材料。</p>
<h4 id="TLS-第三次握手-1"><a href="#TLS-第三次握手-1" class="headerlink" title="TLS 第三次握手"></a>TLS 第三次握手</h4><p>​		客户端收到了服务端的证书后，自然要校验证书是否合法，如果证书合法，那么服务端到身份就是没问题的。校验证书的过程会走证书链逐级验证，确认证书的真实性，再用证书的公钥验证签名，这样就能确认服务端的身份了，确认无误后，就可以继续往下走。</p>
<p>​		客户端会生成一个随机数作为客户端椭圆曲线的私钥，然后再根据服务端前面给的信息，生成<strong>客户端的椭圆曲线公钥</strong>，然后用「<strong>Client Key Exchange</strong>」消息发给服务端。</p>
<img src="https://s2.loli.net/2023/01/12/uAgfJyCaFD5kBm3.png" alt="img" style="zoom:80%;" />

<p>​		至此，双方都有对方的椭圆曲线公钥、自己的椭圆曲线私钥、椭圆曲线基点 G。于是，双方都就计算出点（x，y），其中 x 坐标值双方都是一样的，前面说 ECDHE 算法时候，说 x 是会话密钥，<strong>但实际应用中，x 还不是最终的会话密钥</strong>。</p>
<p>​		<strong>最终的会话密钥，就是用「客户端随机数 + 服务端随机数 + x（ECDHE 算法算出的共享密钥） 」三个材料生成的</strong>。</p>
<p>​		之所以这么麻烦，是因为 TLS 设计者不信任客户端或服务器「伪随机数」的可靠性，为了保证真正的完全随机，把三个不可靠的随机数混合起来，那么「随机」的程度就非常高了，足够让黑客计算不出最终的会话密钥，安全性更高。算好会话密钥后，客户端会发一个「<strong>Change Cipher Spec</strong>」消息，告诉服务端后续改用对称算法加密通信。</p>
<img src="https://s2.loli.net/2023/01/12/7ts8OrY3oxSG4mk.png" alt="img" style="zoom:80%;" />

<p>​		接着，客户端会发「<strong>Encrypted Handshake Message</strong>」消息，把之前发送的数据做一个摘要，再用对称密钥加密一下，让服务端做个验证，验证下本次生成的对称密钥是否可以正常使用。</p>
<img src="https://s2.loli.net/2023/01/12/LfvdMltzDa7Q2gR.png" alt="img" style="zoom:80%;" />

<h4 id="TLS-第四次握手-1"><a href="#TLS-第四次握手-1" class="headerlink" title="TLS 第四次握手"></a>TLS 第四次握手</h4><p>​		最后，服务端也会有一个同样的操作，发「<strong>Change Cipher Spec</strong>」和「<strong>Encrypted Handshake Message</strong>」消息，如果双方都验证加密和解密没问题，那么握手正式完成。于是，就可以正常收发加密的 HTTP 请求和响应了。</p>
<h3 id="RSA-和-ECDHE-握手过程的区别"><a href="#RSA-和-ECDHE-握手过程的区别" class="headerlink" title="RSA 和 ECDHE 握手过程的区别"></a>RSA 和 ECDHE 握手过程的区别</h3><ul>
<li>RSA 密钥协商算法「不支持」前向保密，ECDHE 密钥协商算法「支持」前向保密；</li>
<li>使用了 RSA 密钥协商算法，TLS 完成四次握手后，才能进行应用数据传输，而对于 ECDHE 算法，客户端可以不用等服务端的最后一次 TLS 握手，就可以提前发出加密的 HTTP 数据，节省了一个消息的往返时间；</li>
<li>使用 ECDHE， <strong>在 TLS 第 2 次握手中，会出现服务器端发出的「Server Key Exchange」消息</strong>，而 RSA 握手过程没有该消息；</li>
</ul>
<h2 id="TSL-1-3升级优化"><a href="#TSL-1-3升级优化" class="headerlink" title="TSL 1.3升级优化"></a>TSL 1.3升级优化</h2><p>​		TLS 1.3 大幅度简化了握手的步骤，<strong>完成 TLS 握手只要 1 RTT</strong>，而且安全性更高。</p>
<p>​		在 TLS 1.2 的握手中，一般是需要 4 次握手，先要通过 Client Hello （第 1 次握手）和 Server Hello（第 2 次握手） 消息协商出后续使用的加密算法，再互相交换公钥（第 3 和 第 4 次握手），然后计算出最终的会话密钥，下图的左边部分就是 TLS 1.2 的握手过程：</p>
<img src="https://s2.loli.net/2023/01/12/auLTQtcg4ePRKop.png" alt="img" style="zoom: 50%;" />

<p>​		上图的右边部分就是 TLS 1.3 的握手过程，可以发现 <strong>TLS 1.3 把 Hello 和公钥交换这两个消息合并成了一个消息，于是这样就减少到只需 1 RTT 就能完成 TLS 握手</strong>。</p>
<p>​		“合并”的具体的做法是：客户端在 Client Hello 消息里带上了支持的椭圆曲线，以及这些椭圆曲线对应的公钥。服务端收到后，选定一个椭圆曲线等参数，然后返回消息时，带上服务端这边的公钥。经过这 1 个 RTT，双方手上已经有生成会话密钥的材料了，于是客户端计算出会话密钥，就可以进行应用数据的加密传输了。</p>
<p>​		而且，TLS1.3 对密码套件进行了“减肥”， <strong>对于密钥交换算法，废除了不支持前向安全性的 RSA 和 DH 算法，只支持 ECDHE 算法</strong>。最后只保留五个加密套件:</p>
<ul>
<li>TLS_AES_128_GCM_SHA256</li>
<li>TLS_AES_256_GCM_SHA384</li>
<li>TLS_CHACHA20_POLY1305_SHA256</li>
<li>TLS_AES_128_GCM_SHA256</li>
<li>TLS_AES_128_GCM_8_SHA256</li>
</ul>
<p>​		可以看到，最后剩下的对称加密算法只有 <strong>AES</strong> 和 <strong>CHACHA20</strong>；分组模式也只剩下 <strong>GCM</strong> 和 <strong>POLY1305</strong>；哈希摘要算法只剩下了 <strong>SHA256</strong> 和 <strong>SHA384</strong> 。</p>
<p>​		之所以 TLS1.3 仅支持这么少的密码套件，是因为 TLS1.2 由于支持各种古老且不安全的密码套件，中间人可以利用降级攻击，伪造客户端的 Client Hello 消息，替换客户端支持的密码套件为一些不安全的密码套件，使得服务器被迫使用这个密码套件进行 HTTPS 连接，从而破解密文。</p>
<h1 id="传输层-TCP"><a href="#传输层-TCP" class="headerlink" title="传输层-TCP"></a>传输层-TCP</h1><h2 id="TCP-基本认识"><a href="#TCP-基本认识" class="headerlink" title="TCP 基本认识"></a>TCP 基本认识</h2><h3 id="TCP头格式"><a href="#TCP头格式" class="headerlink" title="TCP头格式"></a>TCP头格式</h3><img src="https://s2.loli.net/2023/01/13/UZqhzcOerS7bMuG.png" alt="TCP 头格式" style="zoom:67%;" />

<p><strong>序列号</strong>：在建立连接时由计算机生成的随机数作为其初始值，通过 SYN 包传给接收端主机，每发送一次数据，就「累加」一次该「数据字节数」的大小。<strong>用来解决网络包乱序问题。</strong></p>
<p><strong>确认应答号</strong>：指下一次「期望」收到的数据的序列号，发送端收到这个确认应答以后可以认为在这个序号以前的数据都已经被正常接收。<strong>用来解决丢包的问题。</strong></p>
<p><strong>控制位：</strong></p>
<ul>
<li><em>ACK</em>：该位为 <code>1</code> 时，「确认应答」的字段变为有效，TCP 规定除了最初建立连接时的 <code>SYN</code> 包之外该位必须设置为 <code>1</code> 。</li>
<li><em>RST</em>：该位为 <code>1</code> 时，表示 TCP 连接中出现异常必须强制断开连接。</li>
<li><em>SYN</em>：该位为 <code>1</code> 时，表示希望建立连接，并在其「序列号」的字段进行序列号初始值的设定。</li>
<li><em>FIN</em>：该位为 <code>1</code> 时，表示今后不会再有数据发送，希望断开连接。当通信结束希望断开连接时，通信双方的主机之间就可以相互交换 <code>FIN</code> 位为 1 的 TCP 段。</li>
</ul>
<h3 id="为什么需要-TCP-协议？-TCP-工作在哪一层？"><a href="#为什么需要-TCP-协议？-TCP-工作在哪一层？" class="headerlink" title="为什么需要 TCP 协议？ TCP 工作在哪一层？"></a>为什么需要 TCP 协议？ TCP 工作在哪一层？</h3><p>​		<code>IP</code> 层（网络层）是「不可靠」的，它不保证网络包的交付、不保证网络包的按序交付、也不保证网络包中的数据的完整性。</p>
<img src="https://s2.loli.net/2023/01/13/xjEFkAMoYy1mSs4.png" alt="OSI 参考模型与 TCP/IP 的关系" style="zoom:67%;" />

<p>​		为保障网络数据包的可靠性，需要由上层<strong>（传输层）的 <code>TCP</code> 协议</strong>来负责。因为 TCP 是一个工作在<strong>传输层</strong>的<strong>可靠</strong>数据传输的服务，它能确保接收端接收的网络包是<strong>无损坏、无间隔、非冗余和按序的。</strong></p>
<h3 id="什么是-TCP"><a href="#什么是-TCP" class="headerlink" title="什么是 TCP"></a>什么是 TCP</h3><p>​		TCP 是<strong>面向连接的、可靠的、基于字节流</strong>的传输层通信协议。</p>
<p><img src="https://s2.loli.net/2023/01/13/QGCX3F2o6aMImST.png" alt="img"></p>
<ul>
<li><strong>面向连接</strong>：一定是「一对一」才能连接，不能像 UDP 协议可以一个主机同时向多个主机发送消息，也就是一对多是无法做到的；</li>
<li><strong>可靠的</strong>：无论的网络链路中出现了怎样的链路变化，TCP 都可以保证一个报文一定能够到达接收端；</li>
<li><strong>字节流</strong>：用户消息通过 TCP 协议传输时，消息可能会被操作系统「分组」成多个的 TCP 报文，如果接收方的程序如果不知道「消息的边界」，是无法读出一个有效的用户消息的。并且 TCP 报文是「有序的」，当「前一个」TCP 报文没有收到的时候，即使它先收到了后面的 TCP 报文，那么也不能扔给应用层去处理，同时对「重复」的 TCP 报文会自动丢弃</li>
</ul>
<h3 id="什么是-TCP-连接"><a href="#什么是-TCP-连接" class="headerlink" title="什么是 TCP 连接"></a>什么是 TCP 连接</h3><p>​		简单来说就是，<strong>用于保证可靠性和流量控制维护的某些状态信息，这些信息的组合，包括Socket、序列号和窗口大小称为连接。</strong></p>
<p><img src="https://s2.loli.net/2023/01/13/Epeh2DYrigqbPKt.png" alt="img"></p>
<p>​		所以我们可以知道，建立一个 TCP 连接是需要客户端与服务端端达成上述三个信息的共识。</p>
<ul>
<li><strong>Socket</strong>：由 IP 地址和端口号组成</li>
<li><strong>序列号</strong>：用来解决乱序问题等</li>
<li><strong>窗口大小</strong>：用来做流量控制</li>
</ul>
<h3 id="如何唯一确定一个-TCP-连接"><a href="#如何唯一确定一个-TCP-连接" class="headerlink" title="如何唯一确定一个 TCP 连接"></a>如何唯一确定一个 TCP 连接</h3><p>​		TCP 四元组可以唯一的确定一个连接，四元组包括如下：</p>
<ul>
<li>源地址</li>
<li>源端口</li>
<li>目的地址</li>
<li>目的端口</li>
</ul>
<img src="https://s2.loli.net/2023/01/13/M1Wu7LpBqF6TlsN.png" alt="TCP 四元组" style="zoom:67%;" />

<p>​		源地址和目的地址的字段（32位）是在 IP 头部中，作用是通过 IP 协议发送报文给对方主机。</p>
<p>​		源端口和目的端口的字段（16位）是在 TCP 头部中，作用是告诉 TCP 协议应该把报文发给哪个进程。</p>
<blockquote>
<p>有一个 IP 的服务端监听了一个端口，它的 TCP 的最大连接数是多少？****</p>
</blockquote>
<p>​		服务端通常固定在某个本地端口上监听，等待客户端的连接请求。因此，客户端 IP 和 端口是可变的，其理论值计算公式如下:</p>
<p><img src="https://s2.loli.net/2023/01/13/xTLYJjUONaGzBke.png" alt="img"></p>
<p>​		对 IPv4，客户端的 IP 数最多为 <code>2</code> 的 <code>32</code> 次方，客户端的端口数最多为 <code>2</code> 的 <code>16</code> 次方，也就是服务端单机最大 TCP 连接数，约为 <code>2</code> 的 <code>48</code> 次方。</p>
<p>​		当然，服务端最大并发 TCP 连接数远不能达到理论上限，会受以下因素影响：</p>
<ul>
<li><p>文件描述符限制</p>
<p>，每个 TCP 连接都是一个文件，如果文件描述符被占满了，会发生 too many open files。Linux 对可打开的文件描述符的数量分别作了三个方面的限制：</p>
<ul>
<li><strong>系统级</strong>：当前系统可打开的最大数量，通过 cat &#x2F;proc&#x2F;sys&#x2F;fs&#x2F;file-max 查看；</li>
<li><strong>用户级</strong>：指定用户可打开的最大数量，通过 cat &#x2F;etc&#x2F;security&#x2F;limits.conf 查看；</li>
<li><strong>进程级</strong>：单个进程可打开的最大数量，通过 cat &#x2F;proc&#x2F;sys&#x2F;fs&#x2F;nr_open 查看；</li>
</ul>
</li>
<li><p><strong>内存限制</strong>，每个 TCP 连接都要占用一定内存，操作系统的内存是有限的，如果内存资源被占满后，会发生 OOM。</p>
</li>
</ul>
<h3 id="TCP-和-UDP-区别"><a href="#TCP-和-UDP-区别" class="headerlink" title="TCP 和 UDP 区别"></a>TCP 和 UDP 区别</h3><h4 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h4><ul>
<li>TCP 是面向连接的传输层协议，传输数据前先要建立连接。</li>
<li>UDP 是不需要连接，即刻传输数据。</li>
</ul>
<h4 id="服务对象"><a href="#服务对象" class="headerlink" title="服务对象"></a>服务对象</h4><ul>
<li>TCP 是一对一的两点服务，即一条连接只有两个端点。</li>
<li>UDP 支持一对一、一对多、多对多的交互通信</li>
</ul>
<h4 id="可靠性"><a href="#可靠性" class="headerlink" title="可靠性"></a>可靠性</h4><ul>
<li>TCP 是可靠交付数据的，数据可以无差错、不丢失、不重复、按序到达。</li>
<li>UDP 是尽最大努力交付，不保证可靠交付数据。但是我们可以基于 UDP 传输协议实现一个可靠的传输协议，比如 QUIC 协议，具体可以参见这篇文章：<a target="_blank" rel="noopener" href="https://xiaolincoding.com/network/3_tcp/quic.html">如何基于 UDP 协议实现可靠传输？(opens new window)</a></li>
</ul>
<h4 id="拥塞控制、流量控制"><a href="#拥塞控制、流量控制" class="headerlink" title="拥塞控制、流量控制"></a>拥塞控制、流量控制</h4><ul>
<li>TCP 有拥塞控制和流量控制机制，保证数据传输的安全性。</li>
<li>UDP 则没有，即使网络非常拥堵了，也不会影响 UDP 的发送速率。</li>
</ul>
<h4 id="首部开销"><a href="#首部开销" class="headerlink" title="首部开销"></a>首部开销</h4><ul>
<li>TCP 首部长度较长，会有一定的开销，首部在没有使用「选项」字段时是 <code>20</code> 个字节，如果使用了「选项」字段则会变长的。</li>
<li>UDP 首部只有 8 个字节，并且是固定不变的，开销较小。</li>
</ul>
<h4 id="传输方式"><a href="#传输方式" class="headerlink" title="传输方式"></a>传输方式</h4><ul>
<li>TCP 是流式传输，没有边界，但保证顺序和可靠。</li>
<li>UDP 是一个包一个包的发送，是有边界的，但可能会丢包和乱序。</li>
</ul>
<h4 id="分片方式"><a href="#分片方式" class="headerlink" title="分片方式"></a>分片方式</h4><ul>
<li>TCP 的数据大小如果大于 MSS 大小，则会在传输层进行分片，目标主机收到后，也同样在传输层组装 TCP 数据包，如果中途丢失了一个分片，只需要传输丢失的这个分片。</li>
<li>UDP 的数据大小如果大于 MTU 大小，则会在 IP 层进行分片，目标主机收到后，在 IP 层组装完数据，接着再传给传输层。</li>
</ul>
<h3 id="TCP-和-UDP-应用场景"><a href="#TCP-和-UDP-应用场景" class="headerlink" title="TCP 和 UDP 应用场景"></a>TCP 和 UDP 应用场景</h3><p>​		TCP 是面向连接，能保证数据的可靠性交付，因此经常用于：</p>
<ul>
<li><p><code>FTP</code> 文件传输；</p>
</li>
<li><p>HTTP &#x2F; HTTPS；</p>
<p>UDP 面向无连接，它可以随时发送数据，再加上 UDP 本身的处理既简单又高效，因此经常用于：</p>
</li>
<li><p>包总量较少的通信，如 <code>DNS</code> 、<code>SNMP</code> 等；</p>
</li>
<li><p>视频、音频等多媒体通信；</p>
</li>
<li><p>广播通信；</p>
</li>
</ul>
<blockquote>
<p>为什么 UDP 头部没有「首部长度」字段，而 TCP 头部有「首部长度」字段呢？</p>
</blockquote>
<p>​		原因是 TCP 有<strong>可变长</strong>的「选项」字段，而 UDP 头部长度则是<strong>不会变化</strong>的，无需多一个字段去记录 UDP 的首部长度。</p>
<blockquote>
<p>为什么 UDP 头部有「包长度」字段，而 TCP 头部则没有「包长度」字段呢？</p>
</blockquote>
<p>​		TCP 是计算负载数据长度的公式如下：</p>
<img src="https://s2.loli.net/2023/01/13/fkqWw6E9DNtXKTH.png" alt="img" style="zoom:80%;" />

<p>​		其中 IP 总长度 和 IP 首部长度，在 IP 首部格式是已知的。TCP 首部长度，则是在 TCP 首部格式已知的，所以就可以求得 TCP 数据的长度。</p>
<p>​		为了网络设备硬件设计和处理方便，首部长度需要是 <code>4</code>字节的整数倍。如果去掉 UDP 「包长度」字段，那 UDP 首部长度就不是 <code>4</code> 字节的整数倍了，所以为了补全 UDP 首部长度是 <code>4</code> 字节的整数倍，UDP补充了「包长度」字段。</p>
<h2 id="TCP-连接建立"><a href="#TCP-连接建立" class="headerlink" title="TCP 连接建立"></a>TCP 连接建立</h2><h3 id="TCP-三次握手"><a href="#TCP-三次握手" class="headerlink" title="TCP 三次握手"></a>TCP 三次握手</h3><p>​		TCP 是面向连接的协议，所以使用 TCP 前必须先建立连接，而<strong>建立连接是通过三次握手来进行的</strong>。三次握手的过程如下图：</p>
<img src="https://s2.loli.net/2023/01/13/LPjruit6EwCTRnx.png" alt="TCP 三次握手" style="zoom:50%;" />

<ul>
<li>一开始，客户端和服务端都处于 <code>CLOSE</code> 状态。先是服务端主动监听某个端口，处于 <code>LISTEN</code> 状态</li>
</ul>
<img src="https://s2.loli.net/2023/01/13/Qk6XtGLKVB53Ona.png" alt="第一个报文—— SYN 报文" style="zoom: 50%;" />

<ul>
<li>客户端会随机初始化序号（<code>client_isn</code>），将此序号置于 TCP 首部的「序号」字段中，同时把 <code>SYN</code> 标志位置为 <code>1</code> ，表示 <code>SYN</code> 报文。接着把第一个 SYN 报文发送给服务端，表示向服务端发起连接，该报文不包含应用层数据，之后客户端处于 <code>SYN-SENT</code> 状态。</li>
</ul>
<img src="https://s2.loli.net/2023/01/13/9ERU3GKOtSodh5v.png" alt="第二个报文 —— SYN + ACK 报文" style="zoom:50%;" />

<ul>
<li>服务端收到客户端的 <code>SYN</code> 报文后，首先服务端也随机初始化自己的序号（<code>server_isn</code>），将此序号填入 TCP 首部的「序号」字段中，其次把 TCP 首部的「确认应答号」字段填入 <code>client_isn + 1</code>, 接着把 <code>SYN</code> 和 <code>ACK</code> 标志位置为 <code>1</code>。最后把该报文发给客户端，该报文也不包含应用层数据，之后服务端处于 <code>SYN-RCVD</code> 状态。</li>
</ul>
<img src="https://s2.loli.net/2023/01/13/yFXJbp4OvLetI1d.png" alt="第三个报文 —— ACK 报文" style="zoom:50%;" />

<ul>
<li>客户端收到服务端报文后，还要向服务端回应最后一个应答报文，首先该应答报文 TCP 首部 <code>ACK</code> 标志位置为 <code>1</code> ，其次「确认应答号」字段填入 <code>server_isn + 1</code> ，最后把报文发送给服务端，这次报文可以携带客户到服务端的数据，之后客户端处于 <code>ESTABLISHED</code> 状态。</li>
<li>服务端收到客户端的应答报文后，也进入 <code>ESTABLISHED</code> 状态。</li>
</ul>
<p>​		从上面的过程可以发现<strong>第三次握手是可以携带数据的，前两次握手是不可以携带数据的</strong>，这也是面试常问的题。一旦完成三次握手，双方都处于 <code>ESTABLISHED</code> 状态，此时连接就已建立完成，客户端和服务端就可以相互发送数据了。</p>
<h3 id="为什么是三次握手？不是两次、四次？"><a href="#为什么是三次握手？不是两次、四次？" class="headerlink" title="为什么是三次握手？不是两次、四次？"></a>为什么是三次握手？不是两次、四次？</h3><p>​		前面我们知道了什么是 <strong>TCP 连接</strong>：用于保证可靠性和流量控制维护的某些状态信息，这些信息的组合，包括<strong>Socket、序列号和窗口大小</strong>称为连接。</p>
<p>​		所以，重要的是<strong>为什么三次握手才可以初始化Socket、序列号和窗口大小并建立 TCP 连接。</strong>接下来，以三个方面分析三次握手的原因：</p>
<ul>
<li>三次握手才可以阻止重复历史连接的初始化（主要原因）</li>
<li>三次握手才可以同步双方的初始序列号</li>
<li>三次握手才可以避免资源浪费</li>
</ul>
<p><em><strong>原因一：避免历史连接</strong></em></p>
<p>​		简单来说，三次握手的<strong>首要原因是为了防止旧的重复连接初始化造成混乱。</strong></p>
<p>​		我们考虑一个场景，客户端先发送了 SYN（seq &#x3D; 90） 报文，然后客户端宕机了，而且这个 SYN 报文还被网络阻塞了，服务端并没有收到，接着客户端重启后，又重新向服务端建立连接，发送了 SYN（seq &#x3D; 100） 报文（<em>注意！不是重传 SYN，重传的 SYN 的序列号是一样的</em>）。</p>
<p>​		看看三次握手是如何阻止历史连接的：</p>
<img src="https://s2.loli.net/2023/01/13/C35nREk6vmiHceD.png" alt="三次握手避免历史连接" style="zoom:50%;" />

<p>​		客户端连续发送多次 SYN （都是同一个四元组）建立连接的报文，在<strong>网络拥堵</strong>情况下：</p>
<ul>
<li>一个「旧 SYN 报文」比「最新的 SYN 」 报文早到达了服务端，那么此时服务端就会回一个 <code>SYN + ACK</code> 报文给客户端，此报文中的确认号是 91（90+1）。</li>
<li>客户端收到后，发现自己期望收到的确认号应该是 100+1，而不是 90 + 1，于是就会回 RST 报文。</li>
<li>服务端收到 RST 报文后，就会释放连接。</li>
<li>后续最新的 SYN 抵达了服务端后，客户端与服务端就可以正常的完成三次握手了。</li>
</ul>
<p>​		上述中的「旧 SYN 报文」称为历史连接，TCP 使用三次握手建立连接的<strong>最主要原因就是防止「历史连接」初始化了连接</strong>。</p>
<blockquote>
<p>TIP</p>
<p>有很多人问，如果服务端在收到 RST 报文之前，先收到了「新 SYN 报文」，也就是服务端收到客户端报文的顺序是：「旧 SYN 报文」-&gt;「新 SYN 报文」，此时会发生什么?</p>
<p>当服务端第一次收到 SYN 报文，也就是收到 「旧 SYN 报文」时，就会回复<code>SYN + ACK</code> 报文给客户端，此报文中的确认号是 91（90+1）。</p>
<p>然后这时再收到「新 SYN 报文」时，就会回 challenge ack (opens new window)报文给客户端，<strong>这个 ack 报文并不是确认收到「新 SYN 报文」的，而是上一次的 ack 确认号</strong>，也就是91（90+1）。所以客户端收到此 ACK 报文时，发现自己期望收到的确认号应该是 101，而不是 91，于是就会回 RST 报文。</p>
</blockquote>
<p>​		<strong>如果是两次握手连接，就无法阻止历史连接</strong>，主要是因为<strong>在两次握手的情况下，服务端没有中间状态给客户端来阻止历史连接，导致服务端可能建立一个历史连接，造成资源浪费</strong>。</p>
<blockquote>
<p>TIP</p>
<p>有人问：客户端发送三次握手（ack 报文）后就可以发送数据了，而被动方此时还是 syn_received 状态，如果 ack 丢了，那客户端发的数据是不是也白白浪费了？</p>
<p>不是的，即使服务端还是在 syn_received 状态，收到了客户端发送的数据，还是可以建立连接的，并且还可以正常收到这个数据包。这是因为数据报文中是有 ack 标识位，也有确认号，这个确认号就是确认收到了第二次握手。如下图：</p>
<img src="https://s2.loli.net/2023/01/13/AuUqsOelN7igjYv.png" alt="img" style="zoom: 50%;" />

<p>所以，服务端收到这个数据报文，是可以正常建立连接的，然后就可以正常接收这个数据包了</p>
</blockquote>
<p><em><strong>原因二：同步双方初始序列号</strong></em></p>
<p>​		TCP 协议的通信双方， 都必须维护一个「序列号」， 序列号是可靠传输的一个关键因素，它的作用：</p>
<ul>
<li>接收方可以去除重复的数据；</li>
<li>接收方可以根据数据包的序列号按序接收；</li>
<li>可以标识发送出去的数据包中， 哪些是已经被对方收到的（通过 ACK 报文中的序列号知道）；</li>
</ul>
<p>​		可见，序列号在 TCP 连接中占据着非常重要的作用，所以当客户端发送携带「初始序列号」的 <code>SYN</code> 报文的时候，需要服务端回一个 <code>ACK</code> 应答报文，表示客户端的 SYN 报文已被服务端成功接收，那当服务端发送「初始序列号」给客户端的时候，依然也要得到客户端的应答回应，<strong>这样一来一回，才能确保双方的初始序列号能被可靠的同步。</strong></p>
<img src="https://s2.loli.net/2023/01/13/24HhUXmbCyEgQxt.png" alt="四次握手与三次握手" style="zoom:50%;" />

<p>​		四次握手其实也能够可靠的同步双方的初始化序号，但由于<strong>第二步和第三步可以优化成一步</strong>，所以就成了「三次握手」。而两次握手只保证了一方的初始序列号能被对方成功接收，没办法保证双方的初始序列号都能被确认接收。</p>
<p><em><strong>原因三：避免资源浪费</strong></em></p>
<p>​		如果只有「两次握手」，当客户端发生的 <code>SYN</code> 报文在网络中阻塞，客户端没有接收到 <code>ACK</code> 报文，就会重新发送 <code>SYN</code> ，<strong>由于没有第三次握手，服务端不清楚客户端是否收到了自己回复的 <code>ACK</code> 报文，所以服务端每收到一个 <code>SYN</code> 就只能先主动建立一个连接</strong>，如果客户端发送的 <code>SYN</code> 报文在网络中阻塞了，重复发送多次 <code>SYN</code> 报文，那么服务端在收到请求后就会<strong>建立多个冗余的无效链接，造成不必要的资源浪费。</strong></p>
<img src="https://s2.loli.net/2023/01/13/dTEfXBP9FkrgWjJ.png" alt="两次握手会造成资源浪费" style="zoom:50%;" />

<p>​		即两次握手会造成消息滞留情况下，服务端重复接受无用的连接请求 <code>SYN</code> 报文，而造成重复分配资源。</p>
<blockquote>
<p>TIP</p>
<p>很多人问，两次握手不是也可以根据上下文信息丢弃 syn 历史报文吗？</p>
<p>我这里两次握手是假设「由于没有第三次握手，服务端不清楚客户端是否收到了自己发送的建立连接的 <code>ACK</code> 确认报文，所以每收到一个 <code>SYN</code> 就只能先主动建立一个连接」这个场景。</p>
<p>当然你要实现成类似三次握手那样，根据上下文丢弃 syn 历史报文也是可以的，两次握手没有具体的实现，怎么假设都行。</p>
</blockquote>
<p><em><strong>总结</strong></em></p>
<p>​		TCP 建立连接时，通过三次握手<strong>能防止历史连接的建立，能减少双方不必要的资源开销，能帮助双方同步初始化序列号</strong>。序列号能够保证数据包不重复、不丢弃和按序传输。</p>
<p>​		不使用「两次握手」和「四次握手」的原因：</p>
<ul>
<li>「两次握手」：无法防止历史连接的建立，会造成双方资源的浪费，也无法可靠的同步双方序列号；</li>
<li>「四次握手」：三次握手就已经理论上最少可靠连接建立，所以不需要使用更多的通信次数。</li>
</ul>
<h3 id="为什么每次建立-TCP-连接时，初始化的序列号都要求不一样"><a href="#为什么每次建立-TCP-连接时，初始化的序列号都要求不一样" class="headerlink" title="为什么每次建立 TCP 连接时，初始化的序列号都要求不一样"></a>为什么每次建立 TCP 连接时，初始化的序列号都要求不一样</h3><p>​		主要原因有两个方面：</p>
<ul>
<li>为了防止历史报文被下一个相同四元组的连接接收（主要方面）；</li>
<li>为了安全性，防止黑客伪造的相同序列号的 TCP 报文被对方接收；</li>
</ul>
<p>​		<strong>如果每次建立连接，客户端和服务端的初始化序列号都是一样的话，很容易出现历史报文被下一个相同四元组的连接接收的问题</strong>。</p>
<img src="https://s2.loli.net/2023/01/13/RDtTuhNWejOZmdr.png" alt="img" style="zoom:50%;" />

<ul>
<li>客户端和服务端建立一个 TCP 连接，在客户端发送数据包被网络阻塞了，然后超时重传了这个数据包，而此时服务端设备断电重启了，之前与客户端建立的连接就消失了，于是在收到客户端的数据包的时候就会发送 RST 报文。</li>
<li>紧接着，客户端又与服务端建立了与上一个连接相同四元组的连接；</li>
<li>在新连接建立完成后，上一个连接中被网络阻塞的数据包正好抵达了服务端，刚好该数据包的序列号正好是在服务端的接收窗口内，所以该数据包会被服务端正常接收，就会造成数据错乱。</li>
</ul>
<p>		</p>
<p>​		而如果每次建立连接客户端和服务端的初始化序列号都「不一样」，就有大概率因为历史报文的序列号「不在」对方接收窗口，从而很大程度上避免了历史报文。</p>
<img src="https://s2.loli.net/2023/01/13/IQbnBTFjwX1AMyx.png" alt="img" style="zoom:50%;" />

<p>​		<strong>注意</strong>：是很大程度上，并不是完全避免了（因为序列号会有回绕的问题，所以需要用时间戳的机制来判断历史报文，详细看篇：<a target="_blank" rel="noopener" href="https://xiaolincoding.com/network/3_tcp/isn_deff.html">TCP 是如何避免历史报文的</a>）。</p>
<h2 id="TCP-和-UDP-能否使用同一个端口"><a href="#TCP-和-UDP-能否使用同一个端口" class="headerlink" title="TCP 和 UDP 能否使用同一个端口"></a>TCP 和 UDP 能否使用同一个端口</h2><p>答案：<strong>可以的</strong>。</p>
<p>​		在数据链路层中，通过 MAC 地址来寻找局域网中的主机。在网际层中，通过 IP 地址来寻找网络中互连的主机或路由器。在传输层中，需要通过端口进行寻址，来识别同一计算机中同时通信的不同应用程序。所以，传输层的「端口号」的作用，是为了区分同一个主机上不同应用程序的数据包。</p>
<p>​		传输层有两个传输协议分别是 TCP 和 UDP，在内核中是两个<strong>完全独立</strong>的软件模块。</p>
<p>​		当主机收到数据包后，可以在 IP 包头的「协议号」字段知道该数据包是 TCP&#x2F;UDP，所以可以根据这个信息确定送给哪个模块（TCP&#x2F;UDP）处理，送给 TCP&#x2F;UDP 模块的报文根据「端口号」确定送给哪个应用程序处理。</p>
<img src="https://s2.loli.net/2023/01/13/AskPTZ1tOm7XGKi.jpg" alt="img" style="zoom:50%;" />

<p>​		因此， TCP&#x2F;UDP 各自的端口号也相互独立，如 TCP 有一个 80 号端口，UDP 也可以有一个 80 号端口，二者并不冲突。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://haoming1130.github.io">Haoming Lu</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://haoming1130.github.io/2023/01/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9/">http://haoming1130.github.io/2023/01/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://haoming1130.github.io" target="_blank">小明学习博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a></div><div class="post_share"><div class="social-share" data-image="https://s2.loli.net/2022/12/04/IWqKCzP5gwNfbVL.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/01/05/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5--day30/"><img class="prev-cover" src="https://s2.loli.net/2022/12/04/IWqKCzP5gwNfbVL.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">算法训练营（day30）</div></div></a></div><div class="next-post pull-right"><a href="/2023/01/04/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5--day29/"><img class="next-cover" src="https://s2.loli.net/2022/12/04/IWqKCzP5gwNfbVL.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">算法训练营（day29）</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div id="comment-switch"><span class="first-comment">Valine</span><span class="switch-btn"></span><span class="second-comment">Disqus</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div><div><div id="disqus_thread"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Haoming Lu</div><div class="author-info__description">一个经常写bug的乖小孩</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">51</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">5</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="mailto:1518244487@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9"><span class="toc-number">1.</span> <span class="toc-text">计算机网络知识点</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#TCP-x2F-IP-%E7%BD%91%E7%BB%9C%E5%88%86%E5%B1%82%E6%A8%A1%E5%9E%8B%E8%AF%A6%E8%A7%A3"><span class="toc-number">2.</span> <span class="toc-text">TCP&#x2F;IP 网络分层模型详解</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%B1%82"><span class="toc-number">2.1.</span> <span class="toc-text">应用层</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%B1%82%E5%8D%8F%E8%AE%AE%E7%AE%80%E8%BF%B0"><span class="toc-number">2.1.1.</span> <span class="toc-text">应用层协议简述</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%A0%E8%BE%93%E5%B1%82"><span class="toc-number">2.2.</span> <span class="toc-text">传输层</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-x2F-UDP"><span class="toc-number">2.2.1.</span> <span class="toc-text">TCP&#x2F;UDP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP%E6%AE%B5"><span class="toc-number">2.2.2.</span> <span class="toc-text">TCP段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AB%AF%E5%8F%A3"><span class="toc-number">2.2.3.</span> <span class="toc-text">端口</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%B1%82"><span class="toc-number">2.3.</span> <span class="toc-text">网络层</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#IP%E5%8D%8F%E8%AE%AE"><span class="toc-number">2.3.1.</span> <span class="toc-text">IP协议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IP%E5%9C%B0%E5%9D%80%E5%AF%BB%E5%9D%80"><span class="toc-number">2.3.2.</span> <span class="toc-text">IP地址寻址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IP%E5%8D%8F%E8%AE%AE%E8%B7%AF%E7%94%B1%E5%8A%9F%E8%83%BD"><span class="toc-number">2.3.3.</span> <span class="toc-text">IP协议路由功能</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E6%8E%A5%E5%8F%A3%E5%B1%82"><span class="toc-number">2.4.</span> <span class="toc-text">网络接口层</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A5%E5%A4%AA%E7%BD%91%E6%A6%82%E5%BF%B5"><span class="toc-number">2.4.1.</span> <span class="toc-text">以太网概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MAC%E5%9C%B0%E5%9D%80"><span class="toc-number">2.4.2.</span> <span class="toc-text">MAC地址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ARP%E5%8D%8F%E8%AE%AE"><span class="toc-number">2.4.3.</span> <span class="toc-text">ARP协议</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ARP%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6"><span class="toc-number">2.4.3.1.</span> <span class="toc-text">ARP工作机制</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">2.5.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%B1%82-HTTP-x2F-HTTPS"><span class="toc-number">3.</span> <span class="toc-text">应用层-HTTP&#x2F;HTTPS</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP%E6%A6%82%E5%BF%B5"><span class="toc-number">3.1.</span> <span class="toc-text">HTTP概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP-%E5%B8%B8%E8%A7%81%E7%9A%84%E7%8A%B6%E6%80%81%E7%A0%81"><span class="toc-number">3.1.1.</span> <span class="toc-text">HTTP 常见的状态码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GET-%E5%92%8C-POST"><span class="toc-number">3.2.</span> <span class="toc-text">GET 和 POST</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#GET-%E5%92%8C-POST-%E6%96%B9%E6%B3%95%E9%83%BD%E6%98%AF%E5%AE%89%E5%85%A8%E5%92%8C%E5%B9%82%E7%AD%89%E7%9A%84%E5%90%97%EF%BC%9F"><span class="toc-number">3.2.1.</span> <span class="toc-text">GET 和 POST 方法都是安全和幂等的吗？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP%E7%89%B9%E6%80%A7"><span class="toc-number">3.3.</span> <span class="toc-text">HTTP特性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP-x2F-1-1"><span class="toc-number">3.3.1.</span> <span class="toc-text">HTTP&#x2F;1.1</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTP-x2F-1-1%E4%BC%98%E7%82%B9"><span class="toc-number">3.3.1.1.</span> <span class="toc-text">HTTP&#x2F;1.1优点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTP-x2F-1-1%E7%BC%BA%E7%82%B9"><span class="toc-number">3.3.1.2.</span> <span class="toc-text">HTTP&#x2F;1.1缺点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTP-x2F-1-1%E6%80%A7%E8%83%BD"><span class="toc-number">3.3.1.3.</span> <span class="toc-text">HTTP&#x2F;1.1性能</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTP-x2F-1-1-%E5%8D%8F%E8%AE%AE%E4%BC%98%E5%8C%96%E6%80%9D%E8%B7%AF"><span class="toc-number">3.3.1.4.</span> <span class="toc-text">HTTP&#x2F;1.1 协议优化思路</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP-x2F-2"><span class="toc-number">3.3.2.</span> <span class="toc-text">HTTP&#x2F;2</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTP-x2F-2%E6%80%A7%E8%83%BD"><span class="toc-number">3.3.2.1.</span> <span class="toc-text">HTTP&#x2F;2性能</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTP-x2F-2%E7%BC%BA%E7%82%B9"><span class="toc-number">3.3.2.2.</span> <span class="toc-text">HTTP&#x2F;2缺点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP-x2F-3"><span class="toc-number">3.3.3.</span> <span class="toc-text">HTTP&#x2F;3</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTP-x2F-3%E6%80%A7%E8%83%BD"><span class="toc-number">3.3.3.1.</span> <span class="toc-text">HTTP&#x2F;3性能</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#QUIC%E5%8D%8F%E8%AE%AE"><span class="toc-number">3.3.3.2.</span> <span class="toc-text">QUIC协议</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTPS%E6%A6%82%E5%BF%B5"><span class="toc-number">3.4.</span> <span class="toc-text">HTTPS概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP-%E4%B8%8E-HTTPS-%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">3.4.1.</span> <span class="toc-text">HTTP 与 HTTPS 有哪些区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTPS-%E8%A7%A3%E5%86%B3%E4%BA%86-HTTP-%E7%9A%84%E5%93%AA%E4%BA%9B%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">3.4.2.</span> <span class="toc-text">HTTPS 解决了 HTTP 的哪些问题？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTPS%E9%80%9A%E4%BF%A1%E6%B5%81%E7%A8%8B"><span class="toc-number">3.4.3.</span> <span class="toc-text">HTTPS通信流程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTPS-%E5%8D%87%E7%BA%A7%E4%BC%98%E5%8C%96"><span class="toc-number">3.5.</span> <span class="toc-text">HTTPS 升级优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%9E%90%E6%80%A7%E8%83%BD%E6%8D%9F%E8%80%97"><span class="toc-number">3.5.1.</span> <span class="toc-text">分析性能损耗</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E4%BC%98%E5%8C%96"><span class="toc-number">3.5.2.</span> <span class="toc-text">硬件优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E4%BC%98%E5%8C%96"><span class="toc-number">3.5.3.</span> <span class="toc-text">软件优化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%8F%E8%AE%AE%E4%BC%98%E5%8C%96"><span class="toc-number">3.5.3.1.</span> <span class="toc-text">协议优化</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AF%86%E9%92%A5%E4%BA%A4%E6%8D%A2%E7%AE%97%E6%B3%95%E4%BC%98%E5%8C%96"><span class="toc-number">3.5.3.1.1.</span> <span class="toc-text">密钥交换算法优化</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TLS-%E5%8D%87%E7%BA%A7"><span class="toc-number">3.5.3.2.</span> <span class="toc-text">TLS 升级</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%81%E4%B9%A6%E4%BC%98%E5%8C%96"><span class="toc-number">3.5.4.</span> <span class="toc-text">证书优化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%81%E4%B9%A6%E4%BC%A0%E8%BE%93%E4%BC%98%E5%8C%96"><span class="toc-number">3.5.4.1.</span> <span class="toc-text">证书传输优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%81%E4%B9%A6%E9%AA%8C%E8%AF%81%E4%BC%98%E5%8C%96"><span class="toc-number">3.5.4.2.</span> <span class="toc-text">证书验证优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E6%9C%89%E5%90%8D%E8%AF%8D%E9%87%8A%E4%B9%89"><span class="toc-number">3.5.4.3.</span> <span class="toc-text">特有名词释义</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%9A%E8%AF%9D%E5%A4%8D%E7%94%A8"><span class="toc-number">3.5.5.</span> <span class="toc-text">会话复用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Session-ID"><span class="toc-number">3.5.5.1.</span> <span class="toc-text">Session ID</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Session-Ticket"><span class="toc-number">3.5.5.2.</span> <span class="toc-text">Session Ticket</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E6%94%BE%E6%94%BB%E5%87%BB"><span class="toc-number">3.5.5.3.</span> <span class="toc-text">重放攻击</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Pre-shared-Key"><span class="toc-number">3.5.5.4.</span> <span class="toc-text">Pre-shared Key</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-number">3.5.6.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RPC%E5%8D%8F%E8%AE%AE"><span class="toc-number">3.6.</span> <span class="toc-text">RPC协议</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E-TCP-%E8%81%8A%E8%B5%B7"><span class="toc-number">3.6.1.</span> <span class="toc-text">从 TCP 聊起</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP-%E5%92%8C-RPC"><span class="toc-number">3.6.2.</span> <span class="toc-text">HTTP 和 RPC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP-x2F-1-1-%E5%92%8C-RPC-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.6.3.</span> <span class="toc-text">HTTP&#x2F;1.1 和 RPC 的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0"><span class="toc-number">3.6.3.1.</span> <span class="toc-text">服务发现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%95%E5%B1%82%E8%BF%9E%E6%8E%A5%E5%BD%A2%E5%BC%8F"><span class="toc-number">3.6.3.2.</span> <span class="toc-text">底层连接形式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%A0%E8%BE%93%E7%9A%84%E5%86%85%E5%AE%B9"><span class="toc-number">3.6.3.3.</span> <span class="toc-text">传输的内容</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-2"><span class="toc-number">3.6.4.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AE%E8%AF%A2%E6%A6%82%E5%BF%B5%E8%A7%A3%E6%9E%90"><span class="toc-number">3.7.</span> <span class="toc-text">轮询概念解析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-HTTP-%E4%B8%8D%E6%96%AD%E8%BD%AE%E8%AF%A2"><span class="toc-number">3.7.1.</span> <span class="toc-text">使用 HTTP 不断轮询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%95%BF%E8%BD%AE%E8%AF%A2"><span class="toc-number">3.7.2.</span> <span class="toc-text">长轮询</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#WebSocket%E5%8D%8F%E8%AE%AE"><span class="toc-number">3.8.</span> <span class="toc-text">WebSocket协议</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BB%BA%E7%AB%8BWebSocket%E8%BF%9E%E6%8E%A5"><span class="toc-number">3.8.1.</span> <span class="toc-text">建立WebSocket连接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#WebSocket%E7%9A%84%E6%B6%88%E6%81%AF%E6%A0%BC%E5%BC%8F"><span class="toc-number">3.8.2.</span> <span class="toc-text">WebSocket的消息格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#WebSocket%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">3.8.3.</span> <span class="toc-text">WebSocket的使用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-3"><span class="toc-number">3.8.4.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%B1%82-SSL-x2F-TSL"><span class="toc-number">4.</span> <span class="toc-text">应用层-SSL&#x2F;TSL</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95"><span class="toc-number">4.1.</span> <span class="toc-text">对称加密算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95"><span class="toc-number">4.2.</span> <span class="toc-text">非对称加密算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E7%A7%B0%E5%92%8C%E9%9D%9E%E5%AF%B9%E7%A7%B0%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.3.</span> <span class="toc-text">对称和非对称的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB"><span class="toc-number">4.4.</span> <span class="toc-text">中间人攻击</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CA-%E2%80%93-%E7%AC%AC%E4%B8%89%E6%96%B9%E8%AE%A4%E8%AF%81%E6%9C%BA%E6%9E%84"><span class="toc-number">4.5.</span> <span class="toc-text">CA – 第三方认证机构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TSL-1-2-%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B"><span class="toc-number">4.6.</span> <span class="toc-text">TSL 1.2 握手过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#RSA-%E6%8F%A1%E6%89%8B%E8%A7%A3%E6%9E%90"><span class="toc-number">4.6.1.</span> <span class="toc-text">RSA 握手解析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RSA%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B"><span class="toc-number">4.6.2.</span> <span class="toc-text">RSA握手过程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#TLS-%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="toc-number">4.6.2.1.</span> <span class="toc-text">TLS 第一次握手</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TLS-%E7%AC%AC%E4%BA%8C%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="toc-number">4.6.2.2.</span> <span class="toc-text">TLS 第二次握手</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TLS-%E7%AC%AC%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="toc-number">4.6.2.3.</span> <span class="toc-text">TLS 第三次握手</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TLS-%E7%AC%AC%E5%9B%9B%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="toc-number">4.6.2.4.</span> <span class="toc-text">TLS 第四次握手</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RSA-%E7%AE%97%E6%B3%95%E7%9A%84%E7%BC%BA%E9%99%B7"><span class="toc-number">4.6.3.</span> <span class="toc-text">RSA 算法的缺陷</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ECDHE-%E6%8F%A1%E6%89%8B%E8%A7%A3%E6%9E%90"><span class="toc-number">4.6.4.</span> <span class="toc-text">ECDHE 握手解析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A6%BB%E6%95%A3%E5%AF%B9%E6%95%B0"><span class="toc-number">4.6.4.1.</span> <span class="toc-text">离散对数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DH-%E7%AE%97%E6%B3%95"><span class="toc-number">4.6.4.2.</span> <span class="toc-text">DH 算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DHE-%E7%AE%97%E6%B3%95"><span class="toc-number">4.6.4.3.</span> <span class="toc-text">DHE 算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ECDHE-%E7%AE%97%E6%B3%95"><span class="toc-number">4.6.4.4.</span> <span class="toc-text">ECDHE 算法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ECDHE-%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B"><span class="toc-number">4.6.5.</span> <span class="toc-text">ECDHE 握手过程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#TLS-%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%8F%A1%E6%89%8B-1"><span class="toc-number">4.6.5.1.</span> <span class="toc-text">TLS 第一次握手</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TLS-%E7%AC%AC%E4%BA%8C%E6%AC%A1%E6%8F%A1%E6%89%8B-1"><span class="toc-number">4.6.5.2.</span> <span class="toc-text">TLS 第二次握手</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TLS-%E7%AC%AC%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B-1"><span class="toc-number">4.6.5.3.</span> <span class="toc-text">TLS 第三次握手</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TLS-%E7%AC%AC%E5%9B%9B%E6%AC%A1%E6%8F%A1%E6%89%8B-1"><span class="toc-number">4.6.5.4.</span> <span class="toc-text">TLS 第四次握手</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RSA-%E5%92%8C-ECDHE-%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.6.6.</span> <span class="toc-text">RSA 和 ECDHE 握手过程的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TSL-1-3%E5%8D%87%E7%BA%A7%E4%BC%98%E5%8C%96"><span class="toc-number">4.7.</span> <span class="toc-text">TSL 1.3升级优化</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BC%A0%E8%BE%93%E5%B1%82-TCP"><span class="toc-number">5.</span> <span class="toc-text">传输层-TCP</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP-%E5%9F%BA%E6%9C%AC%E8%AE%A4%E8%AF%86"><span class="toc-number">5.1.</span> <span class="toc-text">TCP 基本认识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP%E5%A4%B4%E6%A0%BC%E5%BC%8F"><span class="toc-number">5.1.1.</span> <span class="toc-text">TCP头格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81-TCP-%E5%8D%8F%E8%AE%AE%EF%BC%9F-TCP-%E5%B7%A5%E4%BD%9C%E5%9C%A8%E5%93%AA%E4%B8%80%E5%B1%82%EF%BC%9F"><span class="toc-number">5.1.2.</span> <span class="toc-text">为什么需要 TCP 协议？ TCP 工作在哪一层？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-TCP"><span class="toc-number">5.1.3.</span> <span class="toc-text">什么是 TCP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-TCP-%E8%BF%9E%E6%8E%A5"><span class="toc-number">5.1.4.</span> <span class="toc-text">什么是 TCP 连接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%94%AF%E4%B8%80%E7%A1%AE%E5%AE%9A%E4%B8%80%E4%B8%AA-TCP-%E8%BF%9E%E6%8E%A5"><span class="toc-number">5.1.5.</span> <span class="toc-text">如何唯一确定一个 TCP 连接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-%E5%92%8C-UDP-%E5%8C%BA%E5%88%AB"><span class="toc-number">5.1.6.</span> <span class="toc-text">TCP 和 UDP 区别</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5"><span class="toc-number">5.1.6.1.</span> <span class="toc-text">连接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%AF%B9%E8%B1%A1"><span class="toc-number">5.1.6.2.</span> <span class="toc-text">服务对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E9%9D%A0%E6%80%A7"><span class="toc-number">5.1.6.3.</span> <span class="toc-text">可靠性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E3%80%81%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6"><span class="toc-number">5.1.6.4.</span> <span class="toc-text">拥塞控制、流量控制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A6%96%E9%83%A8%E5%BC%80%E9%94%80"><span class="toc-number">5.1.6.5.</span> <span class="toc-text">首部开销</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%A0%E8%BE%93%E6%96%B9%E5%BC%8F"><span class="toc-number">5.1.6.6.</span> <span class="toc-text">传输方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E7%89%87%E6%96%B9%E5%BC%8F"><span class="toc-number">5.1.6.7.</span> <span class="toc-text">分片方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-%E5%92%8C-UDP-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">5.1.7.</span> <span class="toc-text">TCP 和 UDP 应用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP-%E8%BF%9E%E6%8E%A5%E5%BB%BA%E7%AB%8B"><span class="toc-number">5.2.</span> <span class="toc-text">TCP 连接建立</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="toc-number">5.2.1.</span> <span class="toc-text">TCP 三次握手</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%9F%E4%B8%8D%E6%98%AF%E4%B8%A4%E6%AC%A1%E3%80%81%E5%9B%9B%E6%AC%A1%EF%BC%9F"><span class="toc-number">5.2.2.</span> <span class="toc-text">为什么是三次握手？不是两次、四次？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%AF%8F%E6%AC%A1%E5%BB%BA%E7%AB%8B-TCP-%E8%BF%9E%E6%8E%A5%E6%97%B6%EF%BC%8C%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E5%BA%8F%E5%88%97%E5%8F%B7%E9%83%BD%E8%A6%81%E6%B1%82%E4%B8%8D%E4%B8%80%E6%A0%B7"><span class="toc-number">5.2.3.</span> <span class="toc-text">为什么每次建立 TCP 连接时，初始化的序列号都要求不一样</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP-%E5%92%8C-UDP-%E8%83%BD%E5%90%A6%E4%BD%BF%E7%94%A8%E5%90%8C%E4%B8%80%E4%B8%AA%E7%AB%AF%E5%8F%A3"><span class="toc-number">5.3.</span> <span class="toc-text">TCP 和 UDP 能否使用同一个端口</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/01/20/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5--day45/" title="算法训练营（day45）">算法训练营（day45）</a><time datetime="2023-01-20T05:04:23.682Z" title="发表于 2023-01-20 13:04:23">2023-01-20</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/01/19/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BF%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0%E7%AC%AC%E4%B8%80%E6%9C%9F/" title="学成在线项目笔记第一期">学成在线项目笔记第一期</a><time datetime="2023-01-19T03:10:53.670Z" title="发表于 2023-01-19 11:10:53">2023-01-19</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/01/19/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5--day44/" title="算法训练营（day44）">算法训练营（day44）</a><time datetime="2023-01-19T02:31:46.221Z" title="发表于 2023-01-19 10:31:46">2023-01-19</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/01/18/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5--day43/" title="算法训练营（day43）">算法训练营（day43）</a><time datetime="2023-01-18T05:20:05.474Z" title="发表于 2023-01-18 13:20:05">2023-01-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/01/17/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5--day42/" title="算法训练营（day42）">算法训练营（day42）</a><time datetime="2023-01-17T03:46:56.846Z" title="发表于 2023-01-17 11:46:56">2023-01-17</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: '',
      appKey: '',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script><script>function loadDisqus () {
  var disqus_config = function () {
    this.page.url = 'http://haoming1130.github.io/2023/01/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9/'
    this.page.identifier = '/2023/01/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9/'
    this.page.title = '计算机网络知识点'
  };

  window.disqusReset = () => {
    DISQUS.reset({
      reload: true,
      config: disqus_config
    })
  }

  if (window.DISQUS) disqusReset()
  else {
    (function() { 
      var d = document, s = d.createElement('script');
      s.src = 'https://.disqus.com/embed.js';
      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    })();
  }

  document.getElementById('darkmode').addEventListener('click', () => {
    setTimeout(() => window.disqusReset(), 200)
  })
}

if ('Valine' === 'Disqus' || !true) {
  if (true) btf.loadComment(document.getElementById('disqus_thread'), loadDisqus)
  else loadDisqus()
} else {
  function loadOtherComment () {
    loadDisqus()
  }
}
</script></div><div class="aplayer no-destroy" data-id="1708664797" data-server="tencent" data-type="playlist" data-order="list" data-fixed="true" data-preload="auto" data-autoplay="false" data-mutex="true" data-listFolded="true" data-narrow="false"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --><script data-pjax>
  function butterfly_footer_beautify_injector_config(){
    var parent_div_git = document.getElementById('footer-wrap');
    var item_html = '<div id="workboard"></div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://beian.miit.gov.cn/#/Integrated/index" style="margin-inline:5px" data-title="本站已在广东省进行备案" title=""><img src="https://img.shields.io/badge/粤ICP备2023004159号-e1d492?style=flat&amp;logo=data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAdCAYAAAC9pNwMAAABS2lUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4KPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS42LWMxNDIgNzkuMTYwOTI0LCAyMDE3LzA3LzEzLTAxOjA2OjM5ICAgICAgICAiPgogPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4KICA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIi8+CiA8L3JkZjpSREY+CjwveDp4bXBtZXRhPgo8P3hwYWNrZXQgZW5kPSJyIj8+nhxg7wAACNlJREFUSInF1mmMVeUdx/Hv2e+5+519mJWBYQZkGxZZxLKJqBXGoLS1iXWrmihotFXaJiTWWlsbl6q1aetWd5u0VkKjNG4YEJSlOCibDLMwM8x679z9nnPP1jcVJUxf+7z6J8+LT37/Z4VvaQhfFS8+sBXbctCDGrVTKlBUH4mxAbI9Hfj0IJLsp6paJ5/tmn20N/D0wKDRMq9F/c3M2U1/V0vDfWMFh+tv/Ig1zYPMabDImPJ52OaXO87W580KggCiiOsJOJ6I3wcNFaaeNKxrt72f2fLGu4FpJ/sDQABRzD22fH7/Yze069vGc6mrDLNIJCDik10sxz2by3VdPM87xzkP9jwPTZFRVI1YUJKH+oy7n3tbvv/P2wW/UQxRWe6w4ZJRptYLHDoCuz8v5cP92XbI762O+h6UVWHnUFbPpU0fEb2A60mMJ7MUi9b/b7UgKhiZMaIxm8YLplLMDPz8hl/EH+rs8TNlUpFf32uyZJGLPDwCiTGUyTWodTN49eUCdz2YwXb9NNcObp1X98WDoufynzMVCEKGn27ayPTWBi5ad8P5iQUkJEnFLjqM9Z+hrVX0vfDe6K2dPRWsW2bwyp9EUifSJB84gdxrkR0eRgv1o/3I4fbbprJ6scqamzVO9pffec1S5ZWY2Nfz5qEy/FqOC2Y3s3j53HMSi18VRjFPwSwg+1RfVbl115vvJrsfej7UGIsYPPGgQ7JXoO+Xx5B3dHEomyJ9x1qiQozkr95h5937aFnVyouPlgJK+Ss7Fxz64OTSxSX+LHYxT2IsRW5kbGI4oHcR0jqoqTjV9se3I7/f8rS/ClS23GxSXhph6L5d9Akm7qqZhHWBQGUJ+CWGFzcg7e7m6D3/ZuW1Ea5YKdA3EojuONi813TqNi+YPYOKUhXDtCeGL26/hakLLiEcdsaHRkRAoLRc4fJrmhnekyF0apgZowWSwwkaa+rw3f8WA1GZZsPP5JEChX8dhZTN6iU6kAcs5s+dHd183SJ0VVKL57pfw6YdRQw23aeWTns47DPTALWlRTR7kMLew6hGgYqUhWXYFFUdPZ6lUBahLA8hVcOftckfi7No7VRAAQqsX1dybfvG1qwriM9mM5mJ4e4jO5Cc01dPqixbr8tWGBQUL4vjGigEEShi+xUmZ2RiR/sJ1pbS8NkgZrKAGw0TsgQsQyFaF/nfYTGprAlMFysbA1pI3mhkR6snhGsaymYGvPyFEb9IdbUE2AzFFTwpRqCtBY0wmdER+hZW4j63gcJj38V+/ErSUZXsYBfjIZHIRW0c2Z8BskCAqN+CbBJBFnyyKjR+Ez57nBxLqpfMUeSISElMBFz6x2Q6OxzWrYjyxWVzEewioU3LCS5vQY6nMUrLwNaxXvoQ59IloFSx54PPAZtQLExVZZDxsVE8J4dn6v4JYatgbSjk0owPw7RGH2ADMo88Z7L20ip8f7gC7fAo0q4+0rt7kEQDvaghVZbiPHUHcyeXcfLjT3jmpR7AYsnSScya3UR8bARVMck7Y/cB75/X6rDf3Fg2dw2jKZm5dXGm1LuAzO5DCo9v6aT0ibco5kzOvLOP+NGTFJtDpPYeZKijk/Rn3QxsfZV7txwhX7ABiZUXBsGvIvguQApNQQva9RMmTvZ2dpVUls+tX/UD7GN/Y8Ws05w6rQF+9vyzg1vZjbvMRJhXiRSU8DpTFFe0QE8S6SfPkOkZoktrB2oAhZWrwljxOPmchiSMYOWNoxNuruFU5vWeXdsojiUon345113dBBQBmTYlTimgdB8nfPo4WjaNFgN9OMEkJ02dnadVt5ki54Esqy+bzKJltVhSPbI3iN2zCyMTeXNCuG7Omm2Zok7PR2+R7jvD8ouruHhmCrB5jVZeYxLdrTP4sr4Vtd9g4MA4qc4c+6cu5NPamfw4P59t2WrA4YdXKkASf7SFivo6PDdEPmf1fRM++zp1bH/0r4I1dD1ODtOWaW4IsvPjL7nqXhloQiSPwjjgMYkMASyGEBkjhISCQwkwzve/18AbT+pk8pVY4UacQi9y+gyZ0eRAw4qHa89LXEx1LXMSPfhDJYRb59BtlLKg2WPT2l6qYl1svtGkrLYckyA1S+t5+2ATm37WCui0LSynsckDNH5zTxAchbQtkx08hDHYiW6NgC0enHBzEZ102UDH8QORdEckjEzZrNWkRydzyx17uGnDXqbUnGZ6dRPjSY91q2TqwjFuvTxLo5Zn5Qo/pumRSFcTLQtybEhGE0fQrDhhJ0VvH2lTnnHPhGtsmWan469apERjI2MH3qN7+7MEfH6ql29CbV7PvsMG32k6yU2XDhEKyZw66eJaRdrXR7CzCcqUNC3zwgymPJRCH4KRRLINimpL14A5Y4GDeOqbsPRVcfuN7Xj44pav/hFfrNT2kr2rsqf2Ibp5pEA14ZIImUyW3t5REkkTXRGQ/DGGhtLginhqCWknQDE5hKf5UFSF9Lj020Q2ul5V1AR2hr+8vuP8Vlc2zMPRxoSjnx7XBC14sDoydahSGq7KdO/HFyrBchxCVfX4fDKp4T7SCQejYODZLrYgIqgKFsNIgQqEYob8mW6yiUyb7Z64LVK/+B85xznnJ3AWzqTzuIX46mr5wLs+UUTyIriBCjRNxguHMJIFDLEEvXEOVRWnSJ0+jCd4CJoGjoedM1CLcXQziW3nMV2TSMBeOx7vWZvPt1r+cMPzE8KunaUkFn0vNrvtqXj34c1W6gzxlEQ6naIoBahtnkMwoFMwIVzSRNguMt53Aj2s4nkSlgPoGqLkICsRNF0gl8rYWuP8+11/w/OOJDEhHPKLCIpOXmi+M9AgP+maiesLifF2T1Rn5ZNj5Lo/Qc/GcPMmhdoqlEgIGzCK4PiCmJKK68p4KfF3qYGuF0qCRUkJTzleUbvQyWRTuE5xYthxQbBs7EISAbkzUFG3VfXXbK2YFi3X/eryfKKnqVBItNjJxDzH8erddC4SqWwcN5WyTtlyO1RP/Lh3eHD76MB40swmiDVJyDLYRhpc5+ub6tse/wWKbvSQEAw1awAAAABJRU5ErkJggg==" alt=""/></a><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px" data-title="本站项目由Github托管" title=""><img src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&amp;logo=GitHub" alt=""/></a><a class="github-badge" target="_blank" href="https://www.upyun.com/?utm_source=lianmeng&amp;utm_medium=referral" style="margin-inline:5px" data-title="本站使用为静态资源提供CDN加速" title=""><img src="https://img.shields.io/badge/CDN-又拍云-orange?style=flat&amp;logo=又拍云" alt=""/></a></p>';
    console.log('已挂载butterfly_footer_beautify')
    parent_div_git.insertAdjacentHTML("beforeend",item_html)
    }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_footer_beautify_injector_config();
  }
  else if (epage === cpage){
    butterfly_footer_beautify_injector_config();
  }
  </script><script async src="https://unpkg.zhimg.com/hexo-butterfly-footer-beautify@1.0.0/lib/runtime.min.js"></script><!-- hexo injector body_end end --></body></html>